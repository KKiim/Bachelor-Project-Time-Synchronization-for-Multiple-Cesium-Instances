<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="Bird data visualization.">
    <meta name="cesium-sandcastle-labels" content="Showcases, DataSources">
    <title>CLS Bird Flight Analysis</title>
    <script type="text/javascript" src="../Sandcastle-header.js">'use strict';</script>
	<script src="https://d3js.org/d3.v4.min.js">'use strict';</script>
	
	 <!-- Things for Syncronization -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="/../../../Build/Cesium/Cesium.js"></script>
    <script src="/../../../Sync/js/reconnecting-websocket.js"></script>
    <script src="/../../../Sync/./web-config.js"></script>
    <script src="/../../../Sync/js/util.js"></script>
    <script src="/../../../Sync/js/Long.min.js"></script>
    <script src="/../../../Sync/js/ByteBufferAB.min.js"></script>
    <script src="/../../../Sync/js/ProtoBuf.min.js"></script>
    <script>
        if (typeof dcodeIO === 'undefined' || !dcodeIO.ProtoBuf) {
            throw (new Error("ProtoBuf.js is not present. Please see www/index.html for manual setup instructions."));
        }
        // Initialize ProtoBuf.js
        var ProtoBuf = dcodeIO.ProtoBuf;
        var CesiumSync = ProtoBuf.loadProtoFile("/../../../Sync/cesiumsync.proto").build("CesiumSync");
    </script>
	
    <script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.20/require.js">'use strict';</script>
	<!-- <script data-main="d3.js" src="../../../ThirdParty/requirejs-2.1.20/require.js"></script> -->
	<!-- <script type="text/javascript" src="d3.min.js"></script> -->
	
    <script type="text/javascript">
    require.config({
        baseUrl : '../../../Source',
        waitSeconds : 60
    });
    </script>
</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
<!-- 
Things that are not working for some reasons (mostly taken from web demos and forums)
- several menus and the extra cesium toolbars
- trajectory interpolation
- camera positioning with similar height when switching birds

-->
<style>
	@import url(3rdParty/jquery-ui-1.10.3/themes/vader/jquery-ui.css);
      <!-- @import url(d3chart.css); -->
      @import url(../../../Build/Cesium/Widgets/widgets.css);
    @import url(../templates/bucket.css);
    <!-- #cesiumContainer { -->
        <!-- width: 640px; -->
		<!-- height: 360px; -->
		<!-- overflow: hidden; -->
    <!-- } -->

	
@const boundary: 250px;

:root{
--leftmar: 20px;
--altspanheight: 180px;
--boundary: 200px;
--bartop: 280px;
}
.telement{
--altspanheight: 180px;
}

.chart rect {
  fill: steelblue;
}

.chart text {
  fill: white;
  font: 10px sans-serif;
  text-anchor: end;
}



.controlPanel3 {
  position: absolute;
  top: var(--bartop);
  left: var(--leftmar);
  background: rgba(42, 42, 42, 0.8);
  color: #edffff;
  white-space: nowrap; 
  padding: 4px 8px;
  border-radius: 4px;
   min-width: 20px;
   min-height: var(--boundary);
   max-width: 30px;
   max-height: var(--boundary);
}

.d3panel {
  position: absolute;
  top: 200px;
  right: var(--leftmar);
  background: rgba(42, 42, 42, 0.8);
  color: #edffff;
  white-space: nowrap; 
  padding: 4px 8px;
  border-radius: 4px;
   min-width: 100px;
   min-height: 10%;
   max-width: 250px;
   max-height: 12%;
    opacity: 0.37;
	filter: alpha(opacity=50);
}
.d3panel:hover {
    opacity: 1.0;
    filter: alpha(opacity=100); /* For IE8 and earlier */
}
.cesium-infoBox {
        width: 25%;
        max-width: none;
    }
	
.controlPanel2 {
  position: auto;
  top: 50px;
  left: 1600px;
  background: rgba(42, 42, 42, 0.8);
  color: #edffff;
  white-space: nowrap; 
  padding: 4px 8px;
  border-radius: 4px;
}

.controlPanel2 {
      position:auto;
      z-index: 1;
      height: 15%;
      min-width: 20px;
	  min-height: 200px;
      max-width: 500px;
      margin: 0 auto;
	  text-align:center;
	  opacity: 0.37;
	filter: alpha(opacity=50);
   }
 .controlPanel2:hover {
    opacity: 1.0;
    filter: alpha(opacity=100); /* For IE8 and earlier */
}
   

.chart div {
  font: 10px sans-serif;
  background-color: steelblue;
  background: rgba(142, 142, 142, 0.8);
  text-align: right;
  padding: 3px;
  margin: 1px;
  color: white;
}
.chartline div {
  font: 10px sans-serif;
  background-color: orangered;
  background: yellow;
  text-align: right;
  color: white;
}

.hidden>div {
	visibility:hidden;
}

.visible>div {
	visibility:visible;
}   

#altAnimation {
    width: 20px;
    height: 2px;
    position: absolute;
    background: red;
}

#altSpan {
    width: 5px;
    height: var(--altspanheight);
    position: absolute;
    background: white;
	top: 10px;
	left: var(--leftmar);
}

.altErnative {
    width: 10px;
    height: 2px;
    position: absolute;
    background: darkgrey;
}
<!-- 
.hidden>div {
	display:none;
}
 For the non selected entities
 For the full altitude span
 For the selected entities
.visible>div {
	display:block;
}	-->
</style>

<div class="fullSize" id="cesiumContainer"></div>
<div id="loadingOverlay"><h1>Get ready...</h1></div>
<div id="toolbar">
	<div id="interpolationMenu"></div>
</div>
<div id="radioSphere" style="position:absolute; top:0px; right:50%; height: 30px">
		<input type="radio" id="sphere" name="sphere"  value="sphere"><label for="sphere">Sphere</label>
		<input type="radio" id="bird" name="sphere" checked="checked" value="bird"><label for="bird">None</label>
</div>

<div id="radioPanel" style="position:absolute; top:0px; right:60%; height: 30px">
		<input type="checkBox" id="altpanel" name="panel" value="AltPanel" checked="checked"><label for="Alt Panel">Alt Panel</label>
</div>

<div id="radioCPanel" style="position:absolute; top:0px; right:64%; height: 30px">
		<input type="checkBox" id="conpanel" name="panel" value="controlPanel" checked="checked"><label for="Con Panel">Control Panel</label>
</div>

<div id="d3panel" class="d3panel">
<svg class="chart"></svg>
</div>

	<!-- <div id="chart"></div> 
	<div id="info" title="Bird sphere representation"></div> -->
	
<!-- <div class="controlPanel2" style="position:fixed; top:20px; right:50%; width: 30vw"> -->
<div id ="altSpace"></div>
<div id="controlPanelAlt" class="controlPanel3" >
<!-- <div id ="altSpan"></div>
<div id="altAnimation"></div> -->
</div>
<div id="controlPanel" class="controlPanel2" style="position:fixed; top:40px; left:10px">
    <h5>Bird navigation: <span id="distLabel"></span></h5>
    <div>
        <button type="button" class="button" id="birdMinus">Previous bird</button>
        <button type="button" class="button" id="birdPlus">Next bird</button>
    </div>
	<div id ="textspace"></div>
</div>
<svg width="300" height="200"></svg>
<!-- <script src="http://d3js.org/d3.v4.min.js"></script> -->

<script id="cesium_sandcastle_script">
'use strict';
// Try D3 for charts

	//var data = [4, 8, 15, 16, 7, 5];
	var margin = {top: 5, right: 5, bottom: 5, left: 5};
    var width = 250 - margin.right;
    var height = 100 - margin.top - margin.bottom;

    // Various scales. These domains make assumptions of data, naturally.
    var xScale = d3.scaleLog().domain([0, 250]).range([0, width]);
    var yScale = d3.scaleLinear().domain([0, 100]).range([height, 0]);
    //var radiusScale = d3.scaleSqrt().domain([0, 5e2]).range([0, 40]);
	
    var colorScale = d3.schemeCategory20c;

    // Create the SVG container and set the origin.
   /* var svg = d3.select("#d3chart").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	d3.select(".d3panel")
	.selectAll("div")
	.data(data)
	.enter().append("div")
    .style("width", function(d) { return d * 7 + "px"; })
    .text(function(d) { return d; });
	*/
	
	// This part is D3 testing: Add a bar chart to the D3 panel
/*var x = d3.scaleLinear()
    .domain([0, d3.max(data)])
    .range([0, width]);

var chart = d3.select(".chart")
    .attr("width", width)
    .attr("height", barHeight * data.length);

var bar = chart.selectAll("g")
    .data(data)
  .enter().append("g")
    .attr("transform", function(d, i) { return "translate(0," + i * barHeight + ")"; });

bar.append("rect")
    .attr("width", x)
    .attr("height", barHeight - 1);

bar.append("text")
    .attr("x", function(d) { return x(d) - 3; })
    .attr("y", barHeight / 2)
    .attr("dy", ".35em")
    .text(function(d) { return d; });
	*/
	var svg = d3.select("svg");
	var g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	var yChartMin = 0; //Min altitude for selected bird, i.e. lower value at start of y axis
	var yChartMax = 1000; // Max
	// General settinga e.g. to move a marker circle, domain is set once after reading data (further below)
	var xMarker = d3.scaleTime()
			.rangeRound([0, width]);
	var d3y = d3.scaleLinear()
			.rangeRound([height, 0]);

	var parseDate = d3.timeParse("%0d-%0m-%Y-%H-%M-%S");																					
	function lineChart(data) {
		
		// Reformat time string
		// [Format dependency]
		//for (int k = 0; k < data.length; k++) {
		//	var s = data[k].date.split("T")[0];
		//	data[k].date = s;
		//	console.log(data[k].date);
		//} 
		
		//remove current line
		d3.select("path.altline").remove();
		//remove current moving dot
		d3.select("circle.circo").remove();
			 
		if  (data === undefined) return;
		//console.log(data);
		var parseTime = d3.timeParse("%d-%b-%y");

		var x = d3.scaleTime()
			.rangeRound([0, width]);

		
		var line = d3.line()
			.x(function(d) { return x(d.date); })
			.y(function(d) { return d3y(d.alt); });
			
		// Either														  
			/*var tString = window.myViewer.clockViewModel.currentTime.toString();
		console.log(tString);
		var circle = svg.append("line")
                          .attr("x1", x(tString))
                          .attr("y1", 5)
                         .attr("x2", x(tString))
                         .attr("y2", 50)
						 .style("stroke", "grey")
						 .attr("class","verline");	   */
						 /*
		var verLine = g.append("verline")          // attach a line
		.style("stroke", "grey")  // colour the line
		.attr("x1", 100)     // x position of the first end of the line
		.attr("y1", 50)      // y position of the first end of the line
		.attr("x2", 300)     // x position of the second end of the line
		.attr("y2", 150);    // y position of the second end of the line
*/
//d3.tsv("data.tsv", function(d) {
  //d.date = parseTime(d.date);
  //d.close = +d.close;
 //return d;
//}, 
//function(error, data) {
//  if (error) throw error;

		x.domain(d3.extent(data, function(d) { return d.date; }));
		d3y.domain(d3.extent(data, function(d) { return d.alt; }));

		yChartMin = d3.extent(d3y.domain())[0];
		yChartMax = d3.extent(d3y.domain())[1];							   
		g.append("g")
		.attr("transform", "translate(0," + height + ")")
		.call(d3.axisBottom(x))
		.select(".domain")
		.remove();

		g.append("g")
		.call(d3.axisLeft(d3y))
		.append("text")
		.attr("fill", "#000")
		.attr("transform", "rotate(-90)")
		.attr("y", 6)
		.attr("dy", "0.71em")
		.attr("text-anchor", "end")
		.text("Alt");

		g.append("path")
      .datum(data)
      .attr("fill", "none")
      .attr("stroke", "steelblue")
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round")
      .attr("stroke-width", 1.5)
      .attr("d", line)
	  .attr("class","altline");
//});

		//var parseDate = d3.timeParse("%0d-%0m-%Y-%H-%M-%S");					
		
						
		var c= g.append("circle")
		.attr("cx", 0)
		 .attr("class","circo")
       .attr("cy",100)
       .attr("r", 3)
       .attr("fill","green")
       .attr("id","altdot");			  

/*
		var x = d3.scaleTime()
			.rangeRound([0, width]);

		// Random magic numbers for now
		var y = d3.scaleLinear()
			.rangeRound([height, 0]);

		var line = d3.line()
			.x(function(d) { return x(d.date); })
			.y(function(d) { return y(d.alt); });
			x.domain(d3.extent(data, function(d) { return d.date; }));
			
		y.domain(d3.extent(data, function(d) { return d.alt; }));

		g.append("g")
			.attr("transform", "translate(0," + height + ")")
			.call(d3.axisBottom(x))
			.select(".domain")
			.remove();

		 g.append("g")
			.call(d3.axisLeft(y))
			.append("text")
			.attr("fill", "#000")
			.attr("transform", "rotate(-90)")
			.attr("y", 6)
			.attr("dy", "0.71em")
			.attr("text-anchor", "end")
			.text("Alt");

		g.append("path")
			  .data(data)
			  .attr("fill", "none")
			  .attr("stroke", "steelblue")
			  .attr("stroke-linejoin", "round")
			  .attr("stroke-linecap", "round")
			  .attr("stroke-width", 1.5)
			  .attr("d", line);
			  */
	}
/*
var svg = d3.select("svg"),
    margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var parseTime = d3.timeParse("%d-%b-%y");

var x = d3.scaleTime()
    .rangeRound([0, width]);

var y = d3.scaleLinear()
    .rangeRound([height, 0]);

var line = d3.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.close); });

d3.tsv("../../SampleData/linedata.tsv", function(d) {
  d.date = parseTime(d.date);
  d.close = +d.close;
  return d;
}, function(error, data) {
  if (error) throw error;

  x.domain(d3.extent(data, function(d) { return d.date; }));
  y.domain(d3.extent(data, function(d) { return d.close; }));

  g.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x))
    .select(".domain")
      .remove();

  g.append("g")
      .call(d3.axisLeft(y))
    .append("text")
      .attr("fill", "#000")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", "0.71em")
      .attr("text-anchor", "end")
      .text("Price ($)");

  g.append("path")
      .datum(data)
      .attr("fill", "none")
      .attr("stroke", "steelblue")
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round")
      .attr("stroke-width", 1.5)
      .attr("d", line);
});

*/
// D3 end

/// Get Movebank data experimental
        	var jsonUrl = "https://www.movebank.org/movebank/service/public/json";
			//var study_id = 5376563;
			//var individual_local_identifiers = ['67487'];			
			var study_id = 16880941; // !! add the Movebank ID for your study, available in the Study Details
	        var individual_local_identifiers = ['Mary', 'Butterball', 'Schaumboch']; // !! add the exact Animal IDs for the animals in the study that you want to show on the map
	        var colors = ['#FFFF00', '#0099FF', '#FF00FF']; // !! specify color codes for the list of Animal IDs above, or use "null" to use default colors
        	// timestamp_start = Date.UTC(2014, 0, 1); // !! enable to limit data display to a time range (note month is from 0 to 11)
        	// timestamp_end = Date.UTC(2014, 11, 31); // !! enable to limit data display to a time range (note month is from 0 to 11)
            // !! timestamp_start and timestamp_end can be made dynamic by using, e.g. "timestamp_start = Date.now()-1000*3600*24*7);" (this would show only locations from the previous week)
	        var max_events_per_individual = 100; // !! change as you like to show more/fewer locations per individual; note that more locations will slow the time it takes the page to load
			 var data;
            var newData = [];
            // To make sure we can access structures in a callback
            var myCesium;
            var myViewer;
			var myBirds; 
            
            var positions;
            var property; //positions

function deepCopy(o) {
                var copy = o,k;
             
                if (o && typeof o === 'object') {
                    copy = Object.prototype.toString.call(o) === '[object Array]' ? [] : {};
                    for (k in o) {
                        copy[k] = deepCopy(o[k]);
                    }
                }
             
                return copy;
            }
            function myCallBack(data0) {
            	
            	data = data0;
                window.newData = deepCopy(data.individuals); // instead of slice
                //console.log(data);
                
                for (var i = 0; i < data.individuals.length; i++) {
                    data.individuals[i].color = colors[i];
                }
                
                /*
                viewer.entities.add({
					position: mymodel.position,
					orientation: new Cesium.VelocityOrientationProperty(mymodel.position),
					model: {
						uri: '../../SampleData/models/FlyingBird/storch_model_2017__1_7lq90.glb',//FalconRotate.gltf', //FalconColor.glb', //Duck.gltf',//bird.gltf /b789.glb
						minimumPixelSize: 32,
						color: Cesium.Color.ALICEBLUE//YELLOW
                    },
                    sphere : theSphere,
					name: mymodel.name,  //.id
					modelMatrix: transform,
					description : dstrings[dstrings.length-1], //descriptionString,
					path: {
						resolution: 1,
						leadTime: 1,
						trailTime: 5,
						material: new Cesium.PolylineGlowMaterialProperty({
							glowPower: 0.1,
							color: Cesium.Color.YELLOW
						}),
					width: 10
					},
					myIndex : i,
					altGain : altGain
		//,orientation : orientation1

                }));
                */
                
                
                window.mstartDate = null;
                window.mendDate = null;
                for (var i = 0; i < data.individuals.length; i++) {
					console.log("New subject found ");
					var thePosition = new myCesium.SampledPositionProperty();
                    for (var j = 0; j < data.individuals[i].locations.length; j++) {
					//console.log("Test "+data.individuals[i].locations[j].timestamp);
					//console.log(j);
                        var ts = data.individuals[i].locations[j].timestamp;
                        var llat = data.individuals[i].locations[j].location_lat;
						var llong = data.individuals[i].locations[j].location_long;
						//console.log(ts+' '+llat+' '+llong);
						// Check here for height, too.
                        // Now we have to build the entity here
                        // Timestamps are milliseconds since 01011970
                        var theTime = new Date(ts); 
                        var theCTime = myCesium.JulianDate.fromDate(theTime);//new Cesium.JulianDate();
                        //console.log(theCTime);
						
						thePosition.addSample(theCTime,myCesium.Cartesian3.fromDegrees(llong, llat, 250));
                        
                        if (window.mstartDate != null) {
						if (myCesium.JulianDate.lessThan(theCTime,window.mstartDate)){
								window.mstartDate = theCTime.clone();
							}                         
                        } else {
                            window.mstartDate = theCTime.clone();
                        }
						if (window.mendDate != null) {
						if (myCesium.JulianDate.lessThan(window.mendDate,theCTime)){
								window.mendDate = theCTime;
							}                            
                        } else {
                            window.mendDate = theCTime.clone();
                        }
                    }
					myViewer.myBirds.push(
					myViewer.entities.add({
						position : thePosition,
						availability : new myCesium.TimeIntervalCollection([new myCesium.TimeInterval({
							start : window.mstartDate,
							stop : window.mendDate
						})]),
						point : {
							pixelSize : 80,
							color : myCesium.Color.TRANSPARENT,
							outlineColor : myCesium.Color.YELLOW,
							outlineWidth : 3
						},
						path: {
						resolution: 1,
						leadTime: 1,
						trailTime: 5,
						material: new myCesium.PolylineGlowMaterialProperty({
							glowPower: 0.1,
							color: myCesium.Color.YELLOW
						}),
					width: 1000
					},
					polyline: {
						material: new myCesium.PolylineGlowMaterialProperty({
							glowPower : 0.2,
							color : myCesium.Color.BLUE
							})
					}
					}));
					
                }
                return data;
            }
            
            // Takes the Cesium instance and a sampled property
			function initialize(Cesium, viewer, birds, property) {
			return new Promise(function (resolve, reject) {
               myCesium = Cesium;
               myViewer = viewer;
			   viewer.myBirds = birds;
               
               $.getJSON(jsonUrl + "?callback=?", {
                    study_id: study_id,
                    individual_local_identifiers: individual_local_identifiers,
                    max_events_per_individual : max_events_per_individual,
                    // timestamp_start: timestamp_start, // !! enable to limit data display to a time range
                    // timestamp_end: timestamp_end, // !! enable to limit data display to a time range
                    sensor_type: "gps" // !! change if needed to specify the sensor type to display; options are gps, argos-doppler-shift, solar-geolocator, radio-transmitter, bird-ring, natural-mark
                }, 
                myCallBack).done(function() {console.log("Finished");console.log(window.newData.length);resolve('Test');});
                });
                /*function (data0) {
                    data = data0;
                    newData = deepCopy(data.individuals); // instead of slice
                    //console.log(data);
                    for (i = 0; i < newData.length; i++) {
    					console.log("Nehew subject ");
    			 	}
                    for (i = 0; i < data.individuals.length; i++) {
                        data.individuals[i].color = colors[i];
                    }
                    //setBounds();
                    //createMarkers();
                    //createPolylines();
                    //createPolylines2();
                    startDate = null;
                    endDate = null;
                    for (i = 0; i < data.individuals.length; i++) {
						console.log("New subject ");
                        for (j = 0; j < data.individuals[i].locations.length; j++) {
						//console.log("Test "+data.individuals[i].locations[j].timestamp);
						
                            ts = data.individuals[i].locations[j].timestamp;
                            if (startDate != null) {
                                startDate = Math.min(startDate, ts);
                                endDate = Math.max(endDate, ts);
                            } else {
                                startDate = ts;
                                endDate = ts;
                            }
                        }
                    }
					}*/
                }

/// End Movebank data			
		</script>
		<link rel="stylesheet" href="http://code.jquery.com/ui/1.10.2/themes/smoothness/jquery-ui.css" />
		<style>
			.ui-datepicker-trigger {
				margin-left: 5px;
				margin-top: 8px;
				margin-bottom: -3px;
				background: transparent;
			}
			
			.ui-datepicker {
				font-size: 10pt;
			}
		</style>
		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
		<script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.18/jquery-ui.min.js" type="text/javascript"></script>
		<!-- <script src="http://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false&libraries=visualization,geometry"></script> -->
		<script type="text/javascript">
'use strict';           
            
            

///// Test only for visibility instead of CSS
$(function() {
  $('#controlPanelAlt').hover(function() {
    $('#controlPanelAlt').css('background-color', 'gray');
  }, function() {
    // on mouseout, reset the background colour
    $('#controlPanelAlt').css('background-color', '');
  });
});
/*
$(document).ready(function(){
		$('.controlPanelAlt').addClass("visible");

		$('.controlPanelAlt').click(function() {
			var $this = $(this);

			if ($this.hasClass("hidden")) {
				$(this).removeClass("hidden").addClass("visible");

			} else {
				$(this).removeClass("visible").addClass("hidden");
			}
		});
	});
*/
/////

//var canvas = document.createElement('canvas');
//canvas.width = 300;
//canvas.height = 300;

// Initialize some globals
var tickTime = 5; // each 0<tickTime<60 seconds we check for a new climbing pole
var maxCPClimbLimit = 100; // Take only positions into account for climbing pole within the last maxClimbLimit meters of climbing
var maxCPDistLimit = 100; // Take only positions into account for climbing pole within maxCPDistLimit meters distance

// Interpolation option index
var iplin = 1; // Linear 
var iplag = 2; // Langrange
var ipher = 3; // Hermite

// Bird index numbers for analysis

var fastestBird = 0; // currently fastest flying
var fastestClimbingBird = 0; // currently fastest climbing
var climbingBird = []; // sequence of fastest climbing bird's index over time

// Corresponding speed values at a time point
var highSpeed = 0; // Highest speed 
var highGain = 0; // Highest altitude gain 
var timeGranularity = 10; // time step size for testing fastest climb and speed (also used to update the leader's marking

// Altitude
var altSpan = 0; //used to find the maximum absolute span between flight altitude
var maxAlt = 0; // Maximum altitude

var svgString = '<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200">' +
       '<foreignObject width="100%" height="100%">' +
       '<div xmlns="http://www.w3.org/1999/xhtml" style="font-size:40px; color: #FF0">' +
         '<em>I</em> like' + 
         '<span style="color:white; text-shadow:0 0 2px blue;">' +
         'Bird</span>' +
       '</div>' +
       '</foreignObject>' +
       '</svg>';

	  
// The string that is used for the content of the information frame (shown when an entity is selected)
var descriptionString = 'Bird'+' Information:'+
		'<div style="text-align:left; padding:5px">' +   '</div>'+
		'<div style="text-align:left; padding:5px">' +   '</div>';
		//'Name</div>';
		//+ '<div style="text-align:center; padding:15px"><button class="trace-button">' +
        //'Show/hide trace</button></div>';//+
		//'<div style="text-align:center; padding:15px"><button class="birdminus-button">' +
        //'Previous bird</button><button class="birdplus-button">' +
        //'Next bird</button></div>';
		//+'<select name="Birds" class="birdlist">';
	   
// Version for the controlPanel
var cpDescriptionString = //'<p> Some text</p>'+
		'<div style="text-align:center; padding:15px"><button class="trace-button"> Show/hide trace</button>'+'<button class="traceall-button" id="traceall">' + 'Show/hide all traces</button></div>' +
		'<div style="text-align:left;padding:15px"><div style="text-align:left;float:left; padding:15px"><button class="zoom-button"> Zoom to all</button></div>' +
		'<div style="text-align:left;padding:15px">Or select from bird list below: </div>'+
		//'<select name="InterPol" class="interpolations"><option value='+iplin+'>'+'Linear'+'</option><option value='+iplag+'>'+'Lagrange'+'</option><option value='+ipher+'>'+'Hermite'+'</option></select>' +
		'<select name="Birds" style="text-align:left;float:right" class="birdlist">';
		//'<div style="text-align:center; padding:15px"><button class="birdminus-button">' +
        //'Previous bird</button><button class="birdplus-button">' + 'Next bird</button></div>'+
		
// Altitude visualization
var altDescriptionString = '<div id ="altSpan"></div><div id="altAnimation"></div>';

//'<img id ="altLine" src="Altbar.png" vspace ="1"  alt="Grafik">';
	   // For the span of altitudes
			// Adapt his to screen size/resolution
function addBars(descString, minA) {
		descString += '<div class="chart" style="width:5%"><div class="chart" id="altBar" style="text-align:center; float:right; height: 100px; width:100%;">' +Math.trunc(minA)+'<div class="chartline"  id="altline" style="color:red; text-align:center;  width:5%; height: 5px;position:absolute"></div>';
		//<div class="chartline"  id="altline" style="text-align:center; right:0px; height: 10px; width:5%;position:absolute"></div>';
		
			// position:fixed;
			//cpDescriptionString +=  ' <script>' + 'myBarchart.draw();'+'<\/script>';
			return descString;
}
        
	var image = new Image();
	image.src = 'data:image/svg+xml;base64,' + window.btoa(svgString);


function addMultipleBillboards(scene) {

        Sandcastle.declare(addMultipleBillboards); // For highlighting in Sandcastle.

        Cesium.when.all([

                         Cesium.loadImage('../images/Cesium_Logo_overlay.png'),

                         Cesium.loadImage('../images/facility.gif')

                        ],

                        function(images) {

            // Once both images are downloaded, they are combined into one image,

            // called a texture atlas, which is assigned to a billboard-collection.

            // Several billboards can be added to the same collection; each billboard

            // references an image in the texture atlas.



            var billboards = new Cesium.BillboardCollection();

            var textureAtlas = scene.createTextureAtlas({

                images : images

            });

            billboards.textureAtlas = textureAtlas;

            // Logo

            billboards.add({

                position : ellipsoid.cartographicToCartesian(Cesium.Cartographic.fromDegrees(-75.59777, 40.03883)),

                imageIndex : 0

            });

            // Facility

            billboards.add({

                position : ellipsoid.cartographicToCartesian(Cesium.Cartographic.fromDegrees(-80.50, 35.14)),

                imageIndex : 1

            });



            // Facility

            billboards.add({

                position : ellipsoid.cartographicToCartesian(Cesium.Cartographic.fromDegrees(-80.12, 25.46)),

                imageIndex : 1

            });

            scene.primitives.add(billboards);

        });

    }


// #######################################


function startup(Cesium) {
    'use strict';

// Our own bing maps key
Cesium.BingMapsApi.defaultKey = 'AsvwQbU014Pa1eLam_v-_HEitUJcmW0GNE3Kjhrya1SMbJGlHoPYojpMzyFmKq0N';
	
//Sandcastle_Begin
//var viewer = new Cesium.Viewer('cesiumContainer');
//Sandcastle_Begin
//var viewer = new Cesium.Viewer('cesiumContainer');
//var viewer = new Cesium.Viewer('cesiumContainer', {
//    vrButton : true
//});

/* Temporary
var bing = new Cesium.BingMapsImageryProvider({
    url : 'http://dev.virtualearth.net',
	key: 'AsvwQbU014Pa1eLam_v-_HEitUJcmW0GNE3Kjhrya1SMbJGlHoPYojpMzyFmKq0N',
    //key : 'Aj36V6IYWMUkiI1_fOnxPyZxkODEupee3R4MbPCqhYZTDo3deX4UdC7Zc67H8zZf',
    mapStyle : Cesium.BingMapsStyle.AERIAL
});
*/


/*var viewer = new Cesium.Viewer('cesiumContainer', {
    imageryProvider : bing,
    baseLayerPicker : false,
    vrButton : true
});
*/
/* Experimenting with the default camera position
var west = 0.0;
var south = 35.0;
var east = 30.0;
var north = 45.0;

var rectangle = Cesium.Rectangle.fromDegrees(west, south, east, north);

Cesium.Camera.DEFAULT_VIEW_FACTOR = 0;
Cesium.Camera.DEFAULT_VIEW_RECTANGLE = rectangle;
*/

// NOTE: Viewer constructed after default view is set.
//var viewer = new Cesium.Viewer('cesiumContainer');
// New stuff from cesium 1.44 documentation
//Initialize the viewer widget with several custom options and mixins.
/*var viewer = new Cesium.Viewer('cesiumContainer', {
    //Start in Columbus Viewer
    //sceneMode : Cesium.SceneMode.COLUMBUS_VIEW,//MORPHING,//COLUMBUS_VIEW,
	vrButton : true,
    //Use Cesium World Terrain
    terrainProvider : Cesium.createWorldTerrain({
        requestWaterMask : true,
		requestVertexNormals : true
    }),
    //Hide the base layer picker
    baseLayerPicker : false,
    //Use OpenStreetMaps
    imageryProvider : bing,
	//Cesium.createOpenStreetMapImageryProvider({
    //    url : 'https://a.tile.openstreetmap.org/'
    //}),
    // Use high-res stars downloaded from https://github.com/AnalyticalGraphicsInc/cesium-assets
 //   skyBox : new Cesium.SkyBox({
  //      sources : {
   //       positiveX : 'stars/TychoSkymapII.t3_08192x04096_80_px.jpg',
    //      negativeX : 'stars/TychoSkymapII.t3_08192x04096_80_mx.jpg',
     //     positiveY : 'stars/TychoSkymapII.t3_08192x04096_80_py.jpg',
      //    negativeY : 'stars/TychoSkymapII.t3_08192x04096_80_my.jpg',
       //   positiveZ : 'stars/TychoSkymapII.t3_08192x04096_80_pz.jpg',
       //   negativeZ : 'stars/TychoSkymapII.t3_08192x04096_80_mz.jpg'
        //}
    //}),
    // Show Columbus View map with Web Mercator projection
    mapProjection : new Cesium.WebMercatorProjection()
});*/
   var modus;

    var url_string = window.location.href;
    var url = new URL(url_string);
	console.log(url);
	if (url.searchParams != undefined && url.searchParams != null) {
	console.log(url.searchParams);
    modus = url.searchParams.get("mode");
    console.log(modus);

    if (modus == 'master' || modus == 'm') {
        modus = 'master'
		console.log('Master');
    } else if (modus == 'slave' || modus == 's')
	{
        modus = 'slave'
    } else {
        modus = 'basic'
    }
	} 
	else {
        modus = 'slave';//'master' //'basic'
    }
console.log(modus);
    $.getScript('/../../../Sync/' + modus +'.js', function() {

// For d3 only
window.myCesium = Cesium;
window.myViewer = viewer;			  

var options = {
    camera : viewer.scene.camera,
    canvas : viewer.scene.canvas
};

var birds = [];//new Array();
var dstrings = [];//new Array();
var timeLines = []; // for line chart, data and altitude


// Helper to draw lines
function drawLine(ctx, startX, startY, endX, endY,color){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.moveTo(startX,startY);
    ctx.lineTo(endX,endY);
    ctx.stroke();
    ctx.restore();
}


// Helper to calculate d3 dateString
var parseDate = d3.timeParse("%0d-%0m-%Y-%H-%M-%S");
function d3Date(cesiumDate) {
	var tmpDate = Cesium.JulianDate.toDate(cesiumDate);
	var dateString = tmpDate.getDate()+"-"+tmpDate.getMonth()+"-"+tmpDate.getFullYear()+"-"+tmpDate.getHours()+"-"+tmpDate.getMinutes()+"-"+tmpDate.getSeconds();
	return parseDate(dateString);
}
//Helper to draw bars
function drawBar(ctx, upperLeftCornerX, upperLeftCornerY, width, height,color){
    ctx.save();
    ctx.fillStyle=color;
    ctx.fillRect(upperLeftCornerX,upperLeftCornerY,width,height);
    ctx.restore();
}

var chartRect = function ()
{
    var canvas  = viewer.scene.canvas;
    var context = canvas.getContext('2d');

    var x       = 50;
    var y       = 50;
    var width   = 100;
    var height  = 100;
    
    context.strokeStyle = 'red';
    context.strokeRect(x, y, width, height);
}

var Barchart = function(options){
    this.options = options;
    this.canvas = options.canvas;
    this.ctx = this.canvas.getContext("2d");
    this.colors = options.colors;
  
    this.draw = function(){
        var maxValue = 0;
        for (var categ in this.options.data){
            maxValue = Math.max(maxValue,this.options.data[categ]);
        }
        var canvasActualHeight = this.canvas.height - this.options.padding * 2;
        var canvasActualWidth = this.canvas.width - this.options.padding * 2;
 
        //drawing the grid lines
        var gridValue = 0;
        while (gridValue <= maxValue){
            var gridY = canvasActualHeight * (1 - gridValue/maxValue) + this.options.padding;
            drawLine(
                this.ctx,
                0,
                gridY,
                this.canvas.width,
                gridY,
                this.options.gridColor
            );
             
            //writing grid markers
            this.ctx.save();
            this.ctx.fillStyle = this.options.gridColor;
            this.ctx.font = "bold 10px Arial";
            this.ctx.fillText(gridValue, 10,gridY - 2);
            this.ctx.restore();
 
            gridValue+=this.options.gridScale;
        }
  
        //drawing the bars
        var barIndex = 0;
        var numberOfBars = Object.keys(this.options.data).length;
        var barSize = (canvasActualWidth)/numberOfBars;
 
        for (categ in this.options.data){
            var val = this.options.data[categ];
            var barHeight = Math.round( canvasActualHeight * val/maxValue) ;
            drawBar(
                this.ctx,
                this.options.padding + barIndex * barSize,
                this.canvas.height - barHeight - this.options.padding,
                barSize,
                barHeight,
                this.colors[barIndex%this.colors.length]
            );
 
            barIndex++;
        }
  
    }
}

// Bird
//Need to wait for image to load before proceeding to draw
/*image.onload = function() {
  canvas.getContext('2d').drawImage(image, 0, 0);

  var svgvar = viewer.entities.add({
    id: 'Bird SVG',
    position: Cesium.Cartesian3.fromDegrees(47.7, 9.1663883),
    billboard: {
      image: canvas
    },
    description: '<p>This is a bird that can be modified.</p>'
  });
};
*/
// End
function progressTo(bird) {
 viewer.flyTo(bird).then(function(){
			viewer.clock.shouldAnimate = false;
                viewer.trackedEntity = bird;
                viewer.selectedEntity = viewer.trackedEntity;
                viewer.clock.multiplier = 1;
                viewer.clock.shouldAnimate = true;
})
}


Sandcastle.addDefaultToolbarMenu([
    {
        text: 'Select mode',
       
        onselect: function () { }
    },

{
    text : 'Bird flight',
   // onselect : function() {
   //     viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/kml/birds.kml', options)).then(function(dataSource){
   //         viewer.clock.shouldAnimate = false;
   //         var rider = dataSource.entities.getById('tour');
   //         viewer.flyTo(rider).then(function(){
   //             viewer.trackedEntity = rider;
   //             viewer.selectedEntity = viewer.trackedEntity;
   //             viewer.clock.multiplier = 2;
   //             viewer.clock.shouldAnimate = true;
  onselect : function() {
		//C:\Kaos\Data\Collective\Mate
		//viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/kml/2014-08-07-70.kml', options)).then(function(dataSource){//birds2 bird70 2014-08-07-70.kml
		//mate.kmz
        //viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/kml/b10.kml', options)).then(function(dataSource){//birds2 bird70 2014-08-07-70.kml
        
        viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/kml/2014-08-07-70.kml', options)).then(function(dataSource){
        
        	// will be filled by initialize
        	property = new Cesium.SampledPositionProperty();
        
			//var promise1 = initialize(Cesium, viewer, birds, property);
			
			//promise1.then(console.log("Promised and delivered"));
			 //for (i = 0; i < newData.length; i++) {
			//		console.log("Nehew subject ");
			 //}
			viewer.clock.shouldAnimate = false;
            var model = dataSource.entities.getById('bird1');
			var model2 = dataSource.entities.getById('bird2');

            //Create the entities after KML loaded
			var positions = new Array();
			//var birds = new Array();
			
            var position = model.position;
			var position2 = model2.position;
			
            //positions.add(position);
            var mydata = dataSource.entities.values;
			
			var loopSize = mydata.length;
			
			var HPR = new Cesium.HeadingPitchRoll((Cesium.Math.toRadians(270)), 0, 0);

			// Initialize the list of bird names for the select in the control panel
			for (var k = 0; k < loopSize; k++) {
				//descriptionString += '<option value='+k+'>'+mydata[k].id+'</option>';
				cpDescriptionString += '<option value='+k+'>'+mydata[k].name+'</option>'; //.id
				
			}
			//descriptionString += '</select>';
			//descriptionString +='<img width="40" src="bimage.svg"/>';
			//descriptionString += '<object type="image/svg+xml" data="bimage.svg">Your browser does not support SVG</object>';
			console.log(window.newData.length);
			
			cpDescriptionString += '</select></div>';
			var minAlt = 10000; //magic 
			//console.log(dataSource.entities); //dataSource.entities._entities.length
			// Only during start we want to store climbing speed per time point to compare between birds and find the fastest
			var climbingSpeed = []; // Holds the max climbing speed for each time point
			for (var i = 0; i < loopSize; i++) {
	
				var mymodel = mydata[i];
				//console.log (dataSource.entities.values.length);
				//var sampleposition = new Cesium.SampledPositionProperty();
				//sampleposition.addSamplesPackedArray(mymodel.position);
				//console.log(mymodel.id);
				
				//var orientation1 = Cesium.Transforms.headingPitchRollQuaternion(mymodel.position,HPR);
				//console.log(mymodel.position.coords.length);
				// local reference frame for rotation, not positioning
				var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(
					Cesium.Cartesian3.fromDegrees(0, 0, 0.0));	
					// Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
				var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
				var heading = -Cesium.Math.PI_OVER_FOUR;//TWO;
				var pitch = 0;//Cesium.Math.PI_OVER_FOUR;
				var roll = 0.0;
				//var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
				var transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, HPR);
	//console.log(mymodel.name);
				dstrings.push(descriptionString);
				dstrings[dstrings.length-1] += 'Bird ID: '+mymodel.name +'<br/>';//'<div style="text-align:center; padding:15px">Zoom to all</div>';
				dstrings[dstrings.length-1] += '  Bird Name: '+ mymodel.id+'<br/>';
				//dstrings[dstrings.length-1] += '<div class="chart"><div style="width: 40px;">42</div></div>';
			
				// Altitude representation
				var ids = ' <div id="alter'+i+'" class="altErnative"></div>';
				//var idst = ' <div id="alter1" class="altErnative"></div>';
				//console.log(ids);
				altDescriptionString += ids;//'<div id=class="altErnative"></div>';

				// SEt the domain for the xMarker function to start and end of timeLine
				xMarker.domain([d3Date(viewer.clock.startTime),d3Date(viewer.clock.stopTime)]);
				// Testing if positions could be read
				//console.log(mydata[i].path);
				var resStart = mymodel.position.getValue(viewer.clock.startTime, new Cesium.Cartesian3());
				var resStop = mymodel.position.getValue(viewer.clock.stopTime, new Cesium.Cartesian3());
				var curTime = new Cesium.JulianDate; 
				// Only temp to read names
				//var fastestBird = 0; // currently fastest flying
				//var fastestClimbingBird = 0; // currently fastest climbing
				//var climbingBird []; // sequence of fastest climbing bird's index over time
				//var highSpeed = 0; // Highest speed 
				//var highGain = 0; // Highest altitude gain 

				Cesium.JulianDate.clone(viewer.clock.startTime,curTime);
				//Object.assign(curTime, viewer.clock.startTime);
				//var curTime = viewer.clock.startTime;
				var endTime = viewer.clock.stopTime;
				
				// Get start and end altitude
				var startAlt = Cesium.Cartographic.fromCartesian(resStart).height;
				var stopAlt = Cesium.Cartographic.fromCartesian(resStop).height;
				var altGain = stopAlt - startAlt;
				var lastAlt = startAlt;
				var altChanges = "Altitude changes ";
				// This is not yet including the intermediate altitude
				if (startAlt < minAlt) minAlt = startAlt;
				if (stopAlt < minAlt) minAlt = stopAlt;
				
				
				var m = 1;
                var tmpPosition = new Cesium.SampledPositionProperty();
                //console.log(typeof mymodel.position);
                Object.assign(tmpPosition, mymodel.position);
                
                // How to get current altitude
                // var thePos = birds[]._position.getValue(viewer.clock.currentTime, new Cesium.Cartesian3());
                // var altitude =  Cesium.Cartographic.fromCartesian(thePos).height;
				
				var timeLine = [];
				var timePointIndex = 0; // at which timepoint are we right now
                while (Cesium.JulianDate.compare(curTime, endTime) < 0) {
					var currentAlt = mymodel.position.getValue(curTime, new Cesium.Cartesian3());
					var height = Cesium.Cartographic.fromCartesian(currentAlt).height;
					if (height > maxAlt) maxAlt = height;
                    ////
					///
						var parseDate = d3.timeParse("%0d-%0m-%Y-%H-%M-%S");
						
						///
					var tmpDate = Cesium.JulianDate.toDate(curTime);
					var dateString = tmpDate.getDate()+"-"+tmpDate.getMonth()+"-"+tmpDate.getFullYear()+"-"+tmpDate.getHours()+"-"+tmpDate.getMinutes()+"-"+tmpDate.getSeconds();
					
					timeLine.push(
					{
						date: parseDate(dateString),
						//date: Cesium.JulianDate.toIso8601(curTime).split("T")[0],
						alt: height
					}
					);
					//console.log(timeLine[timeLine.length-1]);
					
					////
					var nextTime = new Cesium.JulianDate;
					Cesium.JulianDate.clone(curTime, nextTime);
					//result next or cur?
                    nextTime = Cesium.JulianDate.addSeconds(curTime, timeGranularity, nextTime);
					// Now take care that the height is not undefined
					if (Cesium.JulianDate.compare(nextTime, endTime) <= 0) {
						//var currentAlt = mymodel.position.getValue(curTime, new Cesium.Cartesian3());
						var nextAlt = mymodel.position.getValue(nextTime, new Cesium.Cartesian3());
						//var height = Cesium.Cartographic.fromCartesian(currentAlt).height;
						//if (height > maxAlt) maxAlt = height;
						var climb = Cesium.Cartographic.fromCartesian(nextAlt).height - Cesium.Cartographic.fromCartesian(currentAlt).height;
						if (i == 0) {
							climbingSpeed[climbingSpeed.length] = climb;
							climbingBird[climbingBird.length] = 0;
							//console.log(timePointIndex+' '+i+' '+climb);
						}
						else {
							if (climb > climbingSpeed[timePointIndex]) {
								climbingSpeed[timePointIndex] = climb;
								climbingBird[timePointIndex] = i;
								//console.log(timePointIndex+' '+i);
							}
							//else {
							//	console.log(climb);
							//}
						}
						timePointIndex++;
					}
					Cesium.JulianDate.addSeconds(curTime, timeGranularity, curTime);
                    //var shallowCopy = { ...tmpPosition };
                    ////curTime += viewer.clock.clockStep; new Cesium.PositionProperty()
					//var resCur = tmpPosition.getValue(curTime, new Cesium.Cartesian3());
					//var curAlt = Cesium.Cartographic.fromCartesian(resCur).height;
                    /*
                    var diffAlt = curAlt - lastAlt;
					lastAlt = curAlt;
					//console.log(diffAlt+" "+lastAlt);
					altChanges = altChanges + diffAlt.toString() + " ";
					console.log(altChanges);
					//console.log(Cesium.Cartographic.fromCartesian(resCur).height);
					//console.log(viewer.clock.startTime);
                    */
					
				}
				timeLines.push(timeLine);
				console.log(altChanges);
				fastestClimbingBird = climbingBird[0];
				
				dstrings[dstrings.length-1] += '  Altitude gain '+ altGain;
				//dstrings[dstrings.length-1] +=  ' <script>' + 'myBarchart.draw();'+'<\/script>'; 
				
				console.log(startAlt+" "+stopAlt);
				//console.log(i+" "+mymodel.position.getValue(viewer.clock.startTime));
				// Position in radians and altitude in meters
				console.log(Cesium.Cartographic.fromCartesian(mymodel.position.getValue(viewer.clock.startTime)));
			// End
			
			//descriptionString +='<img width="40" src="bimage.svg"/>';
			//descriptionString += '<object type="image/svg+xml" data="bimage.svg">Your browser does not support SVG</object>';
                //var theBird = new Cesium.entity();
                var theSphere = viewer.entities.add({
                    position: mymodel.position, //Cesium.Cartesian3.fromDegrees(-98.0, 45.0, height),
                    ellipsoid: {
                        radii: new Cesium.Cartesian3(10.0, 10.0, 10.0),
                        outline: true,
                        outlineColor: Cesium.Color.WHITE,
                        outlineWidth: 2,
                        material: Cesium.Color.fromAlpha(Cesium.Color.WHITE,0.35)//Cesium.Color.fromRandom({ alpha: 0.5 })						
						//granularity: Cesium.Math.RADIANS_PER_DEGREE*2
                    },
					show: false,
                    description: 'Bird ID'+mymodel.id,
                    birdId: i,
                    bid: i,
                    //id: mymodel.id,
                    name: "Sphere"//,
                    //parent: theBird
                });
				
				var degreeArray = [];
			for (var li = 0; li < mymodel.position.length; li++) {
				degreeArray.push(mymodel.position[i].longitude);
				degreeArray.push(mymodel.position[i].latitude);
				degreeArray.push(mymodel.position[i].height);
			}
				//mymodel.position
			// Add entities
			// This is just the index!
			
			var theBird = birds.push(
				viewer.entities.add({
					position: mymodel.position,
					orientation: new Cesium.VelocityOrientationProperty(mymodel.position),
					model: {
						//uri: '../../SampleData/models/CesiumMan/cesium_man.glb',//FlyingBird/FalconRotateWaveT.glb',//FalconRotate.gltf', //FalconColor.glb', //Duck.gltf',//bird.gltf /b789.glb																																					  
						uri: '../../SampleData/models/FlyingBird/storch_model_2017__1_7lq90.glb',//FalconRotate.gltf', //FalconColor.glb', //Duck.gltf',//bird.gltf Stork_1_BLEND.glb//b789.glb
						minimumPixelSize: 32,
						color: Cesium.Color.CORNSILK,
						colorBlendMode: Cesium.ColorBlendMode.MIX, //REPLACE,
						colorBlendAmount: 0.6
                    },
                    sphere : theSphere,
					name: mymodel.name,  //.id
					modelMatrix: transform,
					description : dstrings[dstrings.length-1], //descriptionString,
					path: {
						resolution: 1,
						leadTime: 1,
						trailTime: 5000,
						material:
						new Cesium.PolylineGlowMaterialProperty({
							glowPower: 1.0,
							color: Cesium.Color.WHITE
						}),
					width: 2
					},
					color: Cesium.Color.WHITE, //Test, remove
					//_color: Cesium.Color.WHITE, //Test, remove
					polyline: {
						//depthFailMaterial: Cesium.Color.WHITE,
						//color: Cesium.Color.WHITE,
						material: Cesium.Color.WHITE//new Cesium.PolylineOutlineMaterialProperty({//PolylineGlowMaterialProperty({
							////glowPower : 1,
							//outlineColor: Cesium.Color.BLUE,
							//color : Cesium.Color.BLUE
							//})
					},
					//wall: {
					//	material : Cesium.Color.BLUE.withAlpha(0.5),
					//	positions: Cesium.Cartesian3.fromDegreesArrayHeights(degreeArray)
					//},
					myIndex : i,
					altGain : altGain,
					tracker: "bird"
		//,orientation : orientation1

                }));
            theSphere.addProperty("pid");
			//if (viewer.entities.values[viewer.entities.values.length-1].wall != undefined) {
			//	viewer.entities.values[viewer.entities.values.length-1].wall.outlineColor = Cesium.Color.RED.withAlpha(0.5);
			//}
			//viewer.entities.values[viewer.entities.values.length-1]._altGain = 1000;
            //theSphere.bid = birds.id;
			//console.log("Bird "+viewer.entities.values[viewer.entities.values.length-1]);
			//theBird._path._leadTime = 0;

    //);
    
    //console.log('Another bird');
	if (i >= 0) {
	//console.log(birds[0]);
		mymodel.show = false;
		//birds[i].polyline.material = Cesium.Color.clone(Cesium.Color.GREEN);
		//console.log(" Bird: "+bviewer,entities[0]);//.polyline.material = Cesium.Color.GREEN;
	}
	
	}
	lineChart(timeLines[0]);
	birds[fastestClimbingBird].sphere.show = true;
	console.log("Vögel: "+birds.length);
	//cpDescriptionString = addBars(cpDescriptionString,minAlt);
	//altDescriptionString = addBars(altDescriptionString,minAlt);
	
	//Infobox interaction
//To subscribe to the observable showInfo boolean property:

//Cesium.knockout.getObservable(viewer.infoBox.viewModel, 'showInfo').subscribe(function(newValue) {
  
//});
//The above function will be called whenever showInfo changes, and newValue will be true or false.
/*
			The InfoBox does indeed run in an iframe for security and sanitation purposes.  You can remove all restrictions by calling the below line of code after creating the view:

				viewer.infoBox.frame.removeAttribute('sandbox');

				Only do this if you are in complete control of the data that will be loaded into the InfoBox, otherwise it is a security issue.

				You can style the infoBox just as easy by injecting any css you want into the viewer.infoBox.frame  for example:

				            var cssLink = frameDocument.createElement("link");
				            cssLink.href = buildModuleUrl('Path/To/Your/CSS/File.css');
				            cssLink.rel = "stylesheet";
				            cssLink.type = "text/css";
				            viewer.infoBox.frame.contentDocument.head.appendChild(cssLink);

				By default, we inject the contents of Widgets/InfoBox/InfoBoxDescription.css

				You can also style outer InfoBox properties by overriding the CSS classes defined in  Widgets/InfoBox/InfoBox.css in your own apps css file. I'm not sure if you'll be able to add draggable support in this way, but you can do a bunch of other stuff.

				If you want to replace the infoBox completely, then simply pass "infoBox: false" to the Viewer constructor. 
				*/
				
// Since the viewer is newly constructed, the iframe is still about:blank.
// This listens for the iframe to change to the Cesium description template,
// which only happens once at startup.
//
/*
viewer.infoBox.frame.addEventListener('load', function() {
    //
    // Now that the description is loaded, register a click listener inside
    // the document of the iframe.
    //
    viewer.infoBox.frame.contentDocument.body.addEventListener('click', function(e) {
        //
        // The document body will be rewritten when the selectedEntity changes,
        // but this body listener will survive.  Now it must determine if it was
        // one of the clickable buttons.
        //
        if (e.target && e.target.className === 'trace-button') {
           console.log('Test');
            //updateDisplay();
        }
    }, false);
}, false);
*/
/*//Changing the infobox dynamically
viewer.infoBox._element.style.maxWidth="none";
viewer.clock.onTick.addEventListener(function(clock)
{
    var time = new Date().getTime();
    time = Math.floor(time/100);//100ms
    var percent = time % 100;
    if(percent<10){percent=100;}
    viewer.infoBox._element.style.width=percent.toString()+"%";
});
*/
	
	/*
	function updateDisplay() {
    viewer.toolbar.innerHTML = 'Number of times you clicked either button: ' + numClicks;
}
updateDisplay();
*/

	function flyToLocation() {
    Sandcastle.declare(flyToLocation);

    // Create callback for browser's geolocation
    function myfly(position) {
        viewer.camera.flyTo({
            destination : Cesium.Cartesian3.fromDegrees(position.coords.longitude, position.coords.latitude, 1000.0)
        });
    }

    // Ask browser for location, and fly there.
    //navigator.geolocation.getCurrentPosition(myfly);
	
}
	//console.log("Avail "+birds[0].isAvailable(viewer.clock.startTime)); //viewer.entities.computeAvailability());
	//viewer.entities.computeAvailability();
	//console.log("Avail "+birds[0].position.getValue()); //viewer.entities.computeAvailability());
	// Initialize
	/*
	d3.select(".circo").attr("cx", function(d) {
		 var tmpDate = Cesium.JulianDate.toDate(viewer.clock.currentTime);
		 var dateString = tmpDate.getDate()+"-"+tmpDate.getMonth()+"-"+tmpDate.getFullYear()+"-"+tmpDate.getHours()+"-"+tmpDate.getMinutes()+"-"+tmpDate.getSeconds();		
		 return x(parseDate(dateString));})
	*/
	/*
	 
		 */
	viewer.clock.onTick.addEventListener(function(clock)
	{
		if (viewer.vrButton.viewModel.isVRMode) {
			console.log("Is on");
			viewer.scene.useWebVR = true;
		}
		var theTime = Math.trunc(clock.currentTime.secondsOfDay % tickTime); // actually larger values than 60 are possible for now
	
		var time = new Date().getTime();
		//console.log(theTime);
		// Every few seconds
		if (theTime == 0) {
			// do something
			//console.log(birds[0].position[0]);//.getCurrentPosition().latitude
		}
		// Now we calculate the index of the current time in the best lists
		var stTime = new Cesium.JulianDate; 
				// Only temp to read names
				//var fastestBird = 0; // currently fastest flying
				//var fastestClimbingBird = 0; // currently fastest climbing
				//var climbingBird []; // sequence of fastest climbing bird's index over time
				//var highSpeed = 0; // Highest speed 
				//var highGain = 0; // Highest altitude gain 

		Cesium.JulianDate.clone(viewer.clock.startTime,stTime);
		var timeDiff = Math.floor(Cesium.JulianDate.secondsDifference(clock.currentTime, stTime)/ timeGranularity);
		
		//console.log(fastestClimbingBird);
		//console.log(climbingBird[timeDiff]);
		if (climbingBird[timeDiff] != fastestClimbingBird) {
			birds[fastestClimbingBird].sphere.material = Cesium.Color.CORNSILK;
			birds[fastestClimbingBird].sphere.show = false;
			birds[climbingBird[timeDiff]].sphere.material = Cesium.Color.CORAL;
			fastestClimbingBird = climbingBird[timeDiff];
			birds[fastestClimbingBird].sphere.show = true;
		}
		
		// Move altitude bar
		// Make that bullet proof without magic numbers asap
		if (viewer.selectedEntity != null && viewer.selectedEntity != undefined)
		{
			var thePos = viewer.selectedEntity._position.getValue(viewer.clock.currentTime, new Cesium.Cartesian3());
			var altitude =  Cesium.Cartographic.fromCartesian(thePos).height;
		
			var elem = document.getElementById("altAnimation"); 
			//var curPos = elem.style.top.substring(0,elem.style.top.length-2);
			//var poschange = parseInt(curPos)+5;
			//console.log(poschange);
			elem.style.top = 10+(maxAlt-altitude)/maxAlt*180 +  'px';
			// Experiment with moving dot
			var elem = document.getElementById("altdot"); 
		
			d3.select(".circo").each(function(d,i) {
		    //console.log("The x position of circle #" + i + " is " + d3.select(this).attr("cx"));
		    var relPos = 100-(altitude-yChartMin)/(yChartMax-yChartMin)*100; //current chart height 100 
			d3.select(this).attr("cy",d3y(altitude));  // relPos);
			d3.select(this).attr("cx",xMarker(d3Date(viewer.clock.currentTime)));
			})									 
		}
		//"alter'+i+'"
		for (k = 0; k < birds.length; k++) {
			var thePosi = birds[k]._position.getValue(viewer.clock.currentTime, new Cesium.Cartesian3());
			if (thePosi == undefined) continue;
			var alti =  Cesium.Cartographic.fromCartesian(thePosi).height;
			var altids = 'alter'+k;
			
			var elem = document.getElementById(altids);
			if (elem != undefined) {
				elem.style.top = 10+(maxAlt-alti)/maxAlt*180 +  'px';
			}
			//console.log(thePosi);
		}
		//time = Math.floor(time/100);//100ms
		//var percent = time % 100;
		//if(percent<10){percent=100;}
		//viewer.infoBox._element.style.width=percent.toString()+"%";
	});

	//#################################
	// Try to play the animation
	Cesium.when(birds[1].readyPromise).then(function() {
		bird[1].activeAnimations.addAll({
			loop : Cesium.ModelAnimationLoop.REPEAT
		});
	});
	//console.log (viewer.entities.values.length);

var scene = viewer.scene;
console.log(viewer.clock.startTime);
console.log(viewer.clock.clockStep);
console.log(viewer.clock.clockRange);

/*var myBarchart = new Barchart(
	    {
	        canvas:scene.canvas,
	        padding:10,
	        gridScale:5,
	        gridColor:"#eeeeee",
	        data:myVinyls,
	        colors:["#a55ca5","#67b6c7", "#bccd7a","#eb9743"]
	    }
	);
	*/
// Model pick handler for testing

var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);

var entity = viewer.entities.add({
        label : {
            show : false,
            showBackground : true,
            font : '48px monospace',
            horizontalOrigin : Cesium.HorizontalOrigin.LEFT,
            verticalOrigin : Cesium.VerticalOrigin.TOP,
            pixelOffset : new Cesium.Cartesian2(15, 0)
        }
    });

handler.setInputAction(function (movement) {
        var pick = scene.pick(movement.endPosition);
        if (Cesium.defined(pick) && Cesium.defined(pick.node) && Cesium.defined(pick.mesh)) {
            //console.log('node: ' + pick.node.name + '. mesh: ' + pick.mesh.name);	
			
			var longitudeString = Cesium.Math.toDegrees(cartographic.longitude).toFixed(2);
            var latitudeString = Cesium.Math.toDegrees(cartographic.latitude).toFixed(2);
			entity.position = pick;
            entity.label.show = true;
            entity.label.text =
                'Lon: ' + ('   ' + longitudeString).slice(-7) + '\u00B0' +
                '\nLat: ' + ('   ' + latitudeString).slice(-7) + '\u00B0';
        }
    },
    Cesium.ScreenSpaceEventType.MOUSE_MOVE
);

// Handle all stuff when bird selection is changed
function updateViews(birdie) {
	lineChart(timeLines[birdie.myIndex]);
}
function selectBird(birdie) {
	viewer.trackedEntity = birdie;
    viewer.selectedEntity = birdie;
	updateViews(birdie);
}

// Camera zoom
var cartographic = new Cesium.Cartographic();
var ellipsoid = viewer.scene.mapProjection.ellipsoid;
var cartesian = new Cesium.Cartesian3();


function setHeight(height) {
    ellipsoid.cartesianToCartographic(viewer.scene.camera.position, cartographic);
    cartographic.height = height;  // convert to meters
	//console.log(cartographic.height);
	//console.log(viewer.scene.camera.getMagnitude());
    ellipsoid.cartographicToCartesian(cartographic, cartesian);
    viewer.scene.camera.position = cartesian;
}


            //
    handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    handler.setInputAction(function (click) {
        var pickedObject = viewer.scene.pick(click.position);

        /* if (pickedObject instanceof Cesium.Cesium3DTileFeature) 
        {
            var propertyNames = pickedObject.getPropertyNames();
            var length = propertyNames.length;
            for (var i = 0; i < length; ++i) {
                var propertyName = propertyNames[i];
                console.log(propertyName + ': ' + pickedObject.getProperty(propertyName));
            }
        }*/
//console.log(click);
        if (Cesium.defined(pickedObject)) {
            var entityId = pickedObject.id._id;
            var obj = viewer.entities.getById(entityId);
            if (obj._name == 'Sphere'){
            	viewer.selectedEntity = birds[obj._birdId];
				
            	 var thePos = birds[obj._birdId]._position.getValue(viewer.clock.currentTime, new Cesium.Cartesian3());
                 var altitude =  Cesium.Cartographic.fromCartesian(thePos).height;
            } else
			// Check if we hit a bird
			if (Cesium.defined(obj.tracker)) {
				//viewer.selectedEntity.model.color = Cesium.Color.CORAL;
				viewer.selectedEntity = obj;
			}
			updateViews(viewer.selectedEntity);
			
            //console.log(entityId + pickedObject.position);
            //console.log(viewer.entities.getById(entityId));
            //viewer.selectedEntity = viewer.getById(birds[pickedObject.bid].id);
            //console.log(pickedObject.birdId);
                //pickedObject.properties.hasProperty("pid"));
            //if (Cesium.defined(pickedObject.pid)) {
              //  console.log(pickedObject.pid);
                //viewer.selectedEntity = pickedObject.parent;
            //}
        } else {
			lineChart(undefined);
		}
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
            //

document.getElementById('radioSphere').addEventListener('click', function (e) {
    // Either on bird or all
    /*
    if (e.target && e.target.id === 'bird') {
        //console.log('clicked')
        viewer.trackedEntity.sphere.show = false;
    } else { viewer.trackedEntity.sphere.show = true;}
    */
	
    if (e.target && e.target.id == "sphere"){
        for ( i = 0; i < birds.length; i++ ) {
                birds[i].sphere.show = true; //!birds[i].sphere.show;
    	}
    }
    else { 
		if (e.target && e.target.id == "bird"){
			for ( i = 0; i < birds.length; i++ ) {
				birds[i].sphere.show = false; //!birds[i].sphere.show;
			} 
		}
	}
            }, false);
	
	
document.getElementById('radioPanel').addEventListener('click', function (e) {
	if (e.target && e.target.id == "altpanel"){
		if ($('#controlPanelAlt').css("visibility") == 'hidden') {
				$('#controlPanelAlt').css('visibility', 'visible');
			}
			else {
				$('#controlPanelAlt').css('visibility', 'hidden');
		}
		if ($('#d3panel').css("visibility") == 'hidden') {
				$('#d3panel').css('visibility', 'visible');
			}
			else {
				$('#d3panel').css('visibility', 'hidden');
		}
	}
}, false);
	
document.getElementById('radioCPanel').addEventListener('click', function (e) {
	if (e.target && e.target.id == "conpanel"){
		if ($('#controlPanel').css("visibility") == 'hidden') {
				$('#controlPanel').css('visibility', 'visible');
			}
			else {
				$('#controlPanel').css('visibility', 'hidden');
		}
	}
}, false);

	
viewer.infoBox.frame.contentDocument.body.addEventListener('click', function(e) {
        //
        // The document body will be rewritten when the selectedEntity changes,
        // but this body listener will survive.  Now it must determine if it was
        // one of the clickable buttons.
        //
        if (e.target && e.target.className === 'trace-button') {
           //console.log(viewer.selectedEntity.myIndex);
		   mydata[viewer.selectedEntity.myIndex].show = !mydata[viewer.selectedEntity.myIndex].show;
            //updateDisplay();
        } else
		if (e.target && e.target.className === 'birdplus-button') {
           //console.log(viewer.selectedEntity.myIndex);
		   var nextEntity = birds[(viewer.selectedEntity.myIndex-1) % birds.length];
		   
		   selectBird(nextEntity);
		   //viewer.trackedEntity = nextEntity;
           //viewer.selectedEntity = viewer.trackedEntity;
		   
		   //mydata[viewer.selectedEntity.myIndex].show = !mydata[viewer.selectedEntity.myIndex].show;
            //updateDisplay();
        } else
		if (e.target && e.target.className === 'birdminus-button') {
           //console.log(viewer.selectedEntity.myIndex);
		   var nextEntityMinus = birds[(viewer.selectedEntity.myIndex-1) % birds.length];
		   
		   selectBird(nextEntityMinus);
		   //viewer.trackedEntity = nextEntityMinus;
           //viewer.selectedEntity = viewer.trackedEntity;
        } 
    }, false);
	
viewer.infoBox.frame.contentDocument.body.addEventListener('change', function(e) {
		if (e.target && e.target.className === 'birdlist') {
           //console.log("Select");
		   //console.log(e.target.value);
		   viewer.trackedEntity = birds[e.target.value];
		   viewer.selectedEntity = birds[e.target.value];
        }
}, false);	

/*
document.getElementById('controlPanel').addEventListener('click', function(e) {
if (e.target && e.target.id == 'birdMinus') {
	var nextEntityMinus = birds[(viewer.selectedEntity.myIndex-1) % birds.length];
		   console.log(viewer.selectedEntity);
		   viewer.trackedEntity = nextEntityMinus;
           viewer.selectedEntity = viewer.trackedEntity;
		   }
},false);

*/

document.getElementById('birdMinus').addEventListener('click', function() {
	
	var newIndex = ((((viewer.selectedEntity.myIndex-1) % birds.length) + birds.length) % birds.length);
	//console.log(newIndex);
	var nextEntityMinus = birds[newIndex];
		   //console.log(viewer.selectedEntity);
		   selectBird(nextEntityMinus);
}, false);

document.getElementById('birdPlus').addEventListener('click', function() {
	
	ellipsoid.cartesianToCartographic(viewer.scene.camera.position, cartographic);
	var camerah = cartographic.height;
	var cameramag = viewer.scene.camera.getMagnitude();
	var nextEntityPlus = birds[(viewer.selectedEntity.myIndex+1) % birds.length];
	
// Temporary change! Set back if flyto is working	
//viewer.flyTo({destination : nextEntityPlus._position.getValue(viewer.clock.currentTime, new Cesium.Cartesian3())}).then(function(){		 
	// Original
	viewer.flyTo(nextEntityPlus).then(function(){
				viewer.clock.shouldAnimate = false;
                //viewer.trackedEntity = nextEntityPlus;
                //viewer.selectedEntity = viewer.trackedEntity;
                viewer.clock.multiplier = 1;
				//setHeight(camerah);
                viewer.clock.shouldAnimate = true;
    });
	selectBird(nextEntityPlus);
		   //viewer.trackedEntity = nextEntityPlus;
           //viewer.selectedEntity = viewer.trackedEntity;
		   //console.log(camerah);
	setHeight(camerah);
	viewer.camera.moveUp(100); //viewer.scene.camera?
	
	//lineChart(timeLines[(viewer.selectedEntity.myIndex+1) % birds.length]);
	//cameramag-viewer.scene.camera.getMagnitude());
}, false);


document.getElementById('textspace').innerHTML = cpDescriptionString;
document.getElementById('controlPanelAlt').innerHTML = altDescriptionString;
//document.getElementById('altSpace').innerHTML = altDescriptionString;
	
	
document.getElementById('controlPanel').addEventListener('click', function(e) {
	if (e.target && e.target.className === 'trace-button') {
	
		mydata[viewer.selectedEntity.myIndex].show = !mydata[viewer.selectedEntity.myIndex].show;
		//console.log(mydata[viewer.selectedEntity.myIndex].kml.author);
	} else
	if (e.target && e.target.className === 'traceall-button') {
		var traces = false;
	// Assumes that we have a representation for each data model
	
	for (var i = 0; i < loopSize; i++) { 
		traces = traces || mydata[i].show;
	}
	traces = !traces;
	for (var i = 0; i < loopSize; i++) { 
		mydata[i].show = traces; //!mydata[i].show;
	}
	}
	else if (e.target && e.target.className === 'zoom-button') {
		viewer.flyTo(viewer.entities);
	}
});

//viewer.vrButton.addEventListener('click', function(e) {
//console.log("Clicked");
//});

/*
document.getElementById('controlPanel').addEventListener('change', function(e) {
		if (e.target && e.target.className === 'birdlist') {
           console.log("Select");
		   console.log(e.target.value);
		   viewer.trackedEntity = birds[e.target.value];
		   viewer.selectedEntity = birds[e.target.value];
        } else
		if (e.target && e.target.className === 'interpolations') {
			var theDegree = 1;
			var theApprox = Cesium.LinearApproximation;
			switch (e.target.value) {
			 case iplin: theDegree = 1; theApprox = Cesium.LinearApproximation; break;
			 case iplag: theDegree = 5; theApprox = Cesium.LagrangePolynomialApproximation; break;
			 case ipher: theDegree = 2; theApprox = Cesium.HermitePolynomialApproximation;break;
			 default: theDegree = 1; // linear
			}

			for (var l = 0; l < loopSize; l++) {
			birds[l].position.setInterpolationOptions({
				interpolationDegree : theDegree,
				interpolationAlgorithm : theApprox
			});
			}
		}
}, false);	

*/

//VRTheWorldTerrainProvider
//Cesium.ArcGisImageServerTerrainProvider
/*
//Deprecated but still valid
var terrainProvider = new Cesium.CesiumTerrainProvider({
    url : 'https://assets.agi.com/stk-terrain/v1/tilesets/world/tiles',
	requestVertexNormals: true
	//,requestWaterMask: true
});

//HighQ
var terrainProviderMeshes = new Cesium.CesiumTerrainProvider({
    url : 'https://assets.agi.com/stk-terrain/v1/tilesets/PAMAP/tiles',
    requestWaterMask : true,
    requestVertexNormals : true
});
*/
//var terrainProviderVR = new Cesium.VRTheWorldTerrainProvider({
//  url : 'https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/'
//});
//viewer.terrainProvider = terrainProvider;

//viewer.terrainProvider = terrainProviderMeshes;
////viewer.terrainProvider = terrainProvider;

//viewer.terrainProvider = terrainProvider;
viewer.scene.globe.enableLighting = true;

    

// Interface
// Toolbar --------------------------


	
//-----
//Add button to view the path from the top down, not working as it moves the time outside the KML range
/*
Sandcastle.addDefaultToolbarButton('View Top Down', function() {
    viewer.trackedEntity = undefined;
    viewer.zoomTo(viewer.entities, new Cesium.HeadingPitchRange(0, Cesium.Math.toRadians(-90)));
});
  

//Add button to view the path from the side
Sandcastle.addToolbarButton('View Side', function() {
    viewer.trackedEntity = undefined;
    viewer.zoomTo(viewer.entities, new Cesium.HeadingPitchRange(Cesium.Math.toRadians(-90), Cesium.Math.toRadians(-15), 7500));
});

   //             viewer.clock.shouldAnimate = true;
            //Add button to track the entity as it moves
Sandcastle.addToolbarButton('View bird1', function() {
    //viewer.trackedEntity = bird[1];
	mydata[1].show = false;
})
*/

// Check why this doesn't work
//progressTo(bird1);

viewer.flyTo(birds[0]).then(function(){
//            viewer.myfly({destination : birds[0]._position.getValue(viewer.clock.currentTime, new Cesium.Cartesian3())}).then(function(){ //bird1).then(function(){
				viewer.clock.shouldAnimate = false;
                viewer.trackedEntity = birds[0];
                viewer.selectedEntity = viewer.trackedEntity;
                viewer.clock.multiplier = 1;
                viewer.clock.shouldAnimate = true;
            });
			
        });
    } // bird adventure on select
    },
    {
        text: 'Simple Bird flight',
        onselect: function () {
            viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/kml/2014-08-07-70.kml', options)).then(function (dataSource) { //Aug0731.kml', options)).then(function (dataSource) {
                viewer.clock.shouldAnimate = false;
                var rider = dataSource.entities.getById('tour');

                rider.model =
                    {
                        uri: '../../SampleData/models/FlyingBird/Stork_1_BLEND.glTF', //storch_model_2017__1_7lq90.glb',//FalconRotate.gltf', //FalconColor.glb', //Duck.gltf',//bird.gltf /b789.glb
                        minimumPixelSize: 32,
                        color: Cesium.Color.ALICEBLUE//YELLOW
                    };
                rider.orientation = new Cesium.VelocityOrientationProperty(rider.position);



                viewer.flyTo(rider).then(function () {
                    /*
                        viewer.entities.add({
                            model: {
                                uri: '../../SampleData/models/FlyingBird/storch_model_2017__1_7lq90.glb',//FalconRotate.gltf', //FalconColor.glb', //Duck.gltf',//bird.gltf /b789.glb
                                minimumPixelSize: 32,
                                color: Cesium.Color.ALICEBLUE//YELLOW
                            },
                    }); 
                    */
                    viewer.trackedEntity = rider;
                    viewer.selectedEntity = viewer.trackedEntity;
                    viewer.clock.multiplier = 2;
                    viewer.clock.shouldAnimate = true;
                });
            });
        }
    },

], 
'toolbar'); //default toolbar

document.getElementById('controlPanel').addEventListener('change', function(e) {
		if (e.target && e.target.className === 'birdlist') {
           console.log("Select");
		   console.log(e.target.value);
		   viewer.trackedEntity = birds[e.target.value];
		   viewer.selectedEntity = birds[e.target.value];
        } else
		if (e.target && e.target.className === 'interpolations') {
			var theDegree = 1;
			var theApprox = Cesium.LinearApproximation;
			switch (e.target.value) {
			 case iplin: theDegree = 1; theApprox = Cesium.LinearApproximation; break;
			 case iplag: theDegree = 5; theApprox = Cesium.LagrangePolynomialApproximation; break;
			 case ipher: theDegree = 2; theApprox = Cesium.HermitePolynomialApproximation;break;
			 default: theDegree = 1; // linear
			}

			for (var l = 0; l < viewer.entities.length; l++) {
			birds[l].position.setInterpolationOptions({
				interpolationDegree : theDegree,
				interpolationAlgorithm : theApprox
			});
			}
		}
}, false);	



	Sandcastle.reset = function() {
		viewer.dataSources.removeAll();
		viewer.clock.clockRange = Cesium.ClockRange.UNBOUNDED;
		viewer.clock.clockStep = Cesium.ClockStep.SYSTEM_CLOCK;
	};
	
// Check why this is not working	
	/*
	//Add a combo box for selecting each interpolation mode.
	Sandcastle.addToolbarMenu([{
    text : 'Interpolation: Linear Approximation',
    onselect : function() {
        viewer.trackedEntity.position.setInterpolationOptions({
            interpolationDegree : 1,
            interpolationAlgorithm : Cesium.LinearApproximation
        });
    }
}, {
    text : 'Interpolation: Lagrange Polynomial Approximation',
    onselect : function() {
        viewer.trackedEntity.position.setInterpolationOptions({
            interpolationDegree : 5,
            interpolationAlgorithm : Cesium.LagrangePolynomialApproximation
        });
    }
}, {
    text : 'Interpolation: Hermite Polynomial Approximation',
    onselect : function() {
        viewer.trackedEntity.position.setInterpolationOptions({
            interpolationDegree : 2,
            interpolationAlgorithm : Cesium.HermitePolynomialApproximation
        });
    }
}], 'interpolationMenu');
*/
	}); // End of master for synchronization
	
//Sandcastle_End
    Sandcastle.finishedLoading();
} // startup cesium
if (typeof Cesium !== "undefined") {
    startup(Cesium);
} else if (typeof require === "function") {
    require(["Cesium"], startup);
}
/*
document.getElementById("div").addEventListener("touchstart", touchHandler, false);
document.getElementById("div").addEventListener("touchmove", touchHandler, false);
document.getElementById("div").addEventListener("touchend", touchHandler, false);

function touchHandler(e) {
  if (e.type == "touchstart") {
    alert("You touched the screen!");
  } else if (e.type == "touchmove") {
    alert("You moved your finger!");
  } else if (e.type == "touchend" || e.type == "touchcancel") {
    alert("You removed your finger from the screen!");
  }
}
*/

/* Height Zoom camera
var viewer = new Cesium.Viewer('cesiumContainer', {
    navigationHelpButton: false,
    animation: false,
    timeline: false
});

var cartographic = new Cesium.Cartographic();
var cartesian = new Cesium.Cartesian3();
var camera = viewer.scene.camera;
var ellipsoid = viewer.scene.mapProjection.ellipsoid;
var toolbar = document.getElementById('toolbar');
toolbar.innerHTML = '<div id="hud"></div>' +
    '<button type="button" class="cesium-button" id="h1km">1km height</button>' +
    '<button type="button" class="cesium-button" id="h10km">10km height</button>' +
    '<button type="button" class="cesium-button" id="h500km">500km height</button>';

toolbar.setAttribute('style', 'background: rgba(42,42,42,0.9); border-radius: 5px;');

var hud = document.getElementById('hud');

viewer.clock.onTick.addEventListener(function(clock) {
    ellipsoid.cartesianToCartographic(camera.positionWC, cartographic);
    hud.innerHTML =
        'Lon: ' + Cesium.Math.toDegrees(cartographic.longitude).toFixed(3) + ' deg<br/>' +
        'Lat: ' + Cesium.Math.toDegrees(cartographic.latitude).toFixed(3) + ' deg<br/>' +
        'Alt: ' + (cartographic.height * 0.001).toFixed(1) + ' km';
});

function setHeightKm(heightInKilometers) {
    ellipsoid.cartesianToCartographic(camera.position, cartographic);
    cartographic.height = heightInKilometers * 1000;  // convert to meters
    ellipsoid.cartographicToCartesian(cartographic, cartesian);
    camera.position = cartesian;
}

document.getElementById('h1km').addEventListener('click', function() {
    setHeightKm(1);
}, false);

document.getElementById('h10km').addEventListener('click', function() {
    setHeightKm(10);
}, false);

document.getElementById('h500km').addEventListener('click', function() {
    setHeightKm(500);
}, false);

*/

</script>
</body>
</html>
<html><head></head><body></body></html>