<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="Bird data visualization.">
    <meta name="cesium-sandcastle-labels" content="Showcases, DataSources">
    <title>CLS Bird Flight Analysis</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
	<script src="https://d3js.org/d3.v4.min.js"></script>
    <!--<script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.20/require.js"></script> -->
	<!-- <script data-main="d3.js" src="../../../ThirdParty/requirejs-2.1.20/require.js"></script> -->
	<!-- <script type="text/javascript" src="d3.min.js"></script> -->

    <!-- Things for Syncronization -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="/../../../Build/Cesium/Cesium.js"></script>
    <script src="/../../../Sync/js/reconnecting-websocket.js"></script>
    <script src="/../../../Sync/./web-config.js"></script>
    <script src="/../../../Sync/js/util.js"></script>
    <script src="/../../../Sync/js/Long.min.js"></script>
    <script src="/../../../Sync/js/ByteBufferAB.min.js"></script>
    <script src="/../../../Sync/js/ProtoBuf.min.js"></script>
    <script>
        if (typeof dcodeIO === 'undefined' || !dcodeIO.ProtoBuf) {
            throw (new Error("ProtoBuf.js is not present. Please see www/index.html for manual setup instructions."));
        }
        // Initialize ProtoBuf.js
        var ProtoBuf = dcodeIO.ProtoBuf;
        var CesiumSync = ProtoBuf.loadProtoFile("/../../../Sync/cesiumsync.proto").build("CesiumSync");
    </script>

    <script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.20/require.js"></script>


    <script type="text/javascript">
    require.config({
        baseUrl : '../../../Source',
        waitSeconds : 60
    });
    </script>
</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
<!-- 
Things that are not working for some reasons (mostly taken from web demos and forums)
- several menus and the extra cesium toolbars
- trajectory interpolation - must be sampledpositionproperty
- camera positioning with similar height when switching birds

-->
<style>
	@import url(3rdParty/jquery-ui-1.10.3/themes/vader/jquery-ui.css);
      <!-- @import url(d3chart.css); -->
      @import url(../../../Build/Cesium/Widgets/widgets.css);
    @import url(../templates/bucket.css);
    

	
@const boundary: 250px;

:root{
--leftmar: 20px;
--altspanheight: 180px;
--boundary: 200px;
--bartop: 280px;
}
.telement{
--altspanheight: 180px;
}

.chart rect {
  fill: steelblue;
}

.chart text {
  fill: white;
  font: 10px sans-serif;
  text-anchor: end;
}



.controlPanel3 {
  position: absolute;
  top: var(--bartop);
  left: var(--leftmar);
  background: rgba(42, 42, 42, 0.8);
  color: #edffff;
  white-space: nowrap; 
  padding: 4px 8px;
  border-radius: 4px;
   min-width: 20px;
   min-height: var(--boundary);
   max-width: 30px;
   max-height: var(--boundary);
}

.d3panel {
  position: absolute;
  top: 500px;
  left: var(--leftmar);
  background: rgba(42, 42, 42, 0.8);
  color: #edffff;
  white-space: nowrap; 
  padding: 4px 8px;
  border-radius: 4px;
   min-width: 100px;
   min-height: 10%;
   max-width: 250px;
   max-height: 12%;
    opacity: 0.37;
	filter: alpha(opacity=50);
}
.d3panel:hover {
    opacity: 1.0;
    filter: alpha(opacity=100); /* For IE8 and earlier */
}
.cesium-infoBox {
        width: 25%;
        max-width: none;
    }
	
.controlPanel2 {
  position: auto;
  top: 50px;
  left: 1600px;
  background: rgba(42, 42, 42, 0.8);
  color: #edffff;
  white-space: nowrap; 
  padding: 4px 8px;
  border-radius: 4px;
}

.controlPanel2 {
      position:auto;
      z-index: 1;
      height: 15%;
      min-width: 20px;
	  min-height: 200px;
      max-width: 500px;
      margin: 0 auto;
	  text-align:center;
	  opacity: 0.37;
	filter: alpha(opacity=50);
   }
 .controlPanel2:hover {
    opacity: 1.0;
    filter: alpha(opacity=100); /* For IE8 and earlier */
}
   

.chart div {
  font: 10px sans-serif;
  background-color: steelblue;
  background: rgba(142, 142, 142, 0.8);
  text-align: right;
  padding: 3px;
  margin: 1px;
  color: white;
}
.chartline div {
  font: 10px sans-serif;
  background-color: orangered;
  background: yellow;
  text-align: right;
  color: white;
}

.hidden>div {
	visibility:hidden;
}

.visible>div {
	visibility:visible;
}   

#altAnimation {
    width: 20px;
    height: 2px;
    position: absolute;
    background: red;
}

#altSpan {
    width: 5px;
    height: var(--altspanheight);
    position: absolute;
    background: white;
	top: 10px;
	left: var(--leftmar);
}

.altErnative {
    width: 10px;
    height: 2px;
    position: absolute;
    background: darkgrey;
}

</style>

<div class="fullSize" id="cesiumContainer"></div>
<div id="loadingOverlay"><h1>Get ready...</h1></div>
<div id="toolbar">
	<div id="interpolationMenu"></div>
</div>
<div id="radioSphere" style="position:absolute; top:0px; right:50%; height: 30px">
		<input type="radio" id="sphere" name="sphere"  value="sphere"><label for="sphere">Sphere</label>
		<input type="radio" id="bird" name="sphere" checked="checked" value="bird"><label for="bird">None</label>
</div>

<div id="radioPanel" style="position:absolute; top:0px; right:60%; height: 30px">
		<input type="checkBox" id="altpanel" name="panel" value="AltPanel" checked="checked"><label for="Alt Panel">Alt Panel</label>
</div>

<div id="radioCPanel" style="position:absolute; top:0px; right:64%; height: 30px">
		<input type="checkBox" id="conpanel" name="panel" value="controlPanel" checked="checked"><label for="Con Panel">Control Panel</label>
</div>

<div id="d3panel" class="d3panel">
<svg class="chart"></svg>
</div>


<div id ="altSpace"></div>
<div id="controlPanelAlt" class="controlPanel3" >

</div>
<div id="controlPanel" class="controlPanel2" style="position:fixed; top:40px; left:10px">
    <h5>Bird navigation: <span id="distLabel"></span></h5>
    <div>
        <button type="button" class="button" id="birdMinus">Previous bird</button>
        <button type="button" class="button" id="birdPlus">Next bird</button>
    </div>
	<div id ="textspace"></div>
</div>
<svg width="300" height="200"></svg>


<script id="cesium_sandcastle_script">









// Try D3 for charts

	//var data = [4, 8, 15, 16, 7, 5];
	var margin = {top: 5, right: 5, bottom: 5, left: 5};
    var width = 250 - margin.right;
    var height = 100 - margin.top - margin.bottom;

    // Various scales. These domains make assumptions of data, naturally.
    var xScale = d3.scaleLog().domain([0, 250]).range([0, width]);
    var yScale = d3.scaleLinear().domain([0, 100]).range([height, 0]);
    //var radiusScale = d3.scaleSqrt().domain([0, 5e2]).range([0, 40]);
	
    var colorScale = d3.schemeCategory20c;

  
	svg = d3.select("svg"),
	g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	function lineChart(data) {
		
		// Reformat time string
		// [Format dependency]
		//for (int k = 0; k < data.length; k++) {
		//	var s = data[k].date.split("T")[0];
		//	data[k].date = s;
		//	console.log(data[k].date);
		//} 
		
		//remove current line
		d3.select("path.altline").remove();
		if  (data === undefined) return;
		//console.log(data);
		var parseTime = d3.timeParse("%d-%b-%y");

		var x = d3.scaleTime()
			.rangeRound([0, width]);

		var y = d3.scaleLinear()
			.rangeRound([height, 0]);

		var line = d3.line()
			.x(function(d) { return x(d.date); })
			.y(function(d) { return y(d.alt); });



		x.domain(d3.extent(data, function(d) { return d.date; }));
		y.domain(d3.extent(data, function(d) { return d.alt; }));

		g.append("g")
		.attr("transform", "translate(0," + height + ")")
		.call(d3.axisBottom(x))
		.select(".domain")
		.remove();

		g.append("g")
		.call(d3.axisLeft(y))
		.append("text")
		.attr("fill", "#000")
		.attr("transform", "rotate(-90)")
		.attr("y", 6)
		.attr("dy", "0.71em")
		.attr("text-anchor", "end")
		.text("Alt");

		g.append("path")
      .datum(data)
      .attr("fill", "none")
      .attr("stroke", "steelblue")
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round")
      .attr("stroke-width", 1.5)
      .attr("d", line)
	  .attr("class","altline");
//});



	}

// D3 end

/// Get Movebank data experimental
        	var jsonUrl = "https://www.movebank.org/movebank/service/public/json";
			var study_id = 16880941; // !! add the Movebank ID for your study, available in the Study Details
	        var individual_local_identifiers = ['Mary', 'Butterball', 'Schaumboch']; // !! add the exact Animal IDs for the animals in the study that you want to show on the map
	        var colors = ['#FFFF00', '#0099FF', '#FF00FF']; // !! specify color codes for the list of Animal IDs above, or use "null" to use default colors
        	// timestamp_start = Date.UTC(2014, 0, 1); // !! enable to limit data display to a time range (note month is from 0 to 11)
        	// timestamp_end = Date.UTC(2014, 11, 31); // !! enable to limit data display to a time range (note month is from 0 to 11)
            // !! timestamp_start and timestamp_end can be made dynamic by using, e.g. "timestamp_start = Date.now()-1000*3600*24*7);" (this would show only locations from the previous week)
	        var max_events_per_individual = 100; // !! change as you like to show more/fewer locations per individual; note that more locations will slow the time it takes the page to load
		</script>
		<link rel="stylesheet" href="http://code.jquery.com/ui/1.10.2/themes/smoothness/jquery-ui.css" />
		<style>
			.ui-datepicker-trigger {
				margin-left: 5px;
				margin-top: 8px;
				margin-bottom: -3px;
				background: transparent;
			}
			
			.ui-datepicker {
				font-size: 10pt;
			}
		</style>
		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
		<script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.18/jquery-ui.min.js" type="text/javascript"></script>
		<!-- <script src="http://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false&libraries=visualization,geometry"></script> -->
		<script type="text/javascript">




            var data;
            var newData;
            // To make sure we can access structures in a callback
            var myCesium;
            var myViewer;
			var myBirds; 
            
            var positions;
            var property; //positions 
            
            function deepCopy(o) {
                var copy = o,k;
             
                if (o && typeof o === 'object') {
                    copy = Object.prototype.toString.call(o) === '[object Array]' ? [] : {};
                    for (k in o) {
                        copy[k] = deepCopy(o[k]);
                    }
                }
             
                return copy;
            }
            function myCallBack(data0) {
            	
            	data = data0;
                newData = deepCopy(data.individuals); // instead of slice
                //console.log(data);
                
                for (i = 0; i < data.individuals.length; i++) {
                    data.individuals[i].color = colors[i];
                }
                
                /*
                viewer.entities.add({
					position: mymodel.position,
					orientation: new Cesium.VelocityOrientationProperty(mymodel.position),
					model: {
						uri: '../../SampleData/models/FlyingBird/storch_model_2017__1_7lq90.glb',//FalconRotate.gltf', //FalconColor.glb', //Duck.gltf',//bird.gltf /b789.glb
						minimumPixelSize: 32,
						color: Cesium.Color.ALICEBLUE//YELLOW
                    },
                    sphere : theSphere,
					name: mymodel.name,  //.id
					modelMatrix: transform,
					description : dstrings[dstrings.length-1], //descriptionString,
					path: {
						resolution: 1,
						leadTime: 1,
						trailTime: 5,
						material: new Cesium.PolylineGlowMaterialProperty({
							glowPower: 0.1,
							color: Cesium.Color.YELLOW
						}),
					width: 10
					},
					myIndex : i,
					altGain : altGain
		//,orientation : orientation1

                }));
                */
                
                
                startDate = null;
                endDate = null;
                for (i = 0; i < data.individuals.length; i++) {
					console.log("New subject ");
					var thePosition = new myCesium.SampledPositionProperty();
                    for (j = 0; j < data.individuals[i].locations.length; j++) {
					//console.log("Test "+data.individuals[i].locations[j].timestamp);
					//console.log(j);
                        var ts = data.individuals[i].locations[j].timestamp;
                        var llat = data.individuals[i].locations[j].location_lat;
						var llong = data.individuals[i].locations[j].location_long;
						console.log(ts+' '+llat+' '+llong);
						// Check here for height, too.
                        // Now we have to build the entity here
                        // Timestamps are milliseconds since 01011970
                        var theTime = new Date(ts); 
                        var theCTime = myCesium.JulianDate.fromDate(theTime);//new Cesium.JulianDate();
                        console.log(theCTime);
						
						thePosition.addSample(theCTime,myCesium.Cartesian3.fromDegrees(llong, llat, 250));
                        
                        if (startDate != null) {
                            startDate = Math.min(startDate, ts);
                            endDate = Math.max(endDate, ts);
                        } else {
                            startDate = ts;
                            endDate = ts;
                        }
                    }
					myBirds.push(
					myViewer.entities.add({
						position : thePosition,
						point : {
							pixelSize : 80,
							color : myCesium.Color.TRANSPARENT,
							outlineColor : myCesium.Color.YELLOW,
							outlineWidth : 3
						},
						path: {
						resolution: 1,
						leadTime: 1,
						trailTime: 5,
						material: new myCesium.PolylineGlowMaterialProperty({
							glowPower: 0.1,
							color: myCesium.Color.YELLOW
						}),
					width: 1000
					},
					polyline: {
						material: new myCesium.PolylineGlowMaterialProperty({
							glowPower : 0.2,
							color : myCesium.Color.BLUE
							})
					}
					}));
					
                }
                return data;
            }
            
            // Takes the Cesium instance and a sampled property
			function initialize(Cesium, viewer, birds, property) {
               myCesium = Cesium;
               myViewer = viewer;
			   myBirds = birds;
               
               $.getJSON(jsonUrl + "?callback=?", {
                    study_id: study_id,
                    individual_local_identifiers: individual_local_identifiers,
                    max_events_per_individual : max_events_per_individual,
                    // timestamp_start: timestamp_start, // !! enable to limit data display to a time range
                    // timestamp_end: timestamp_end, // !! enable to limit data display to a time range
                    sensor_type: "gps" // !! change if needed to specify the sensor type to display; options are gps, argos-doppler-shift, solar-geolocator, radio-transmitter, bird-ring, natural-mark
                }, 
                myCallBack
                
            
                )}

/// End Movebank data

///// Test only for visibility instead of CSS
$(function() {
  $('#controlPanelAlt').hover(function() {
    $('#controlPanelAlt').css('background-color', 'gray');
  }, function() {
    // on mouseout, reset the background colour
    $('#controlPanelAlt').css('background-color', '');
  });
});

/////


// Initialize some globals
var tickTime = 5; // each 0<tickTime<60 seconds we check for a new climbing pole
var maxCPClimbLimit = 100; // Take only positions into account for climbing pole within the last maxClimbLimit meters of climbing
var maxCPDistLimit = 100; // Take only positions into account for climbing pole within maxCPDistLimit meters distance

// Interpolation option index
var iplin = 1; // Linear 
var iplag = 2; // Langrange
var ipher = 3; // Hermite

// Bird index numbers for analysis

var fastestBird = 0; // currently fastest flying
var fastestClimbingBird = 0; // currently fastest climbing
var climbingBird = []; // sequence of fastest climbing bird's index over time

// Corresponding speed values at a time point
var highSpeed = 0; // Highest speed 
var highGain = 0; // Highest altitude gain 
var timeGranularity = 10; // time step size for testing fastest climb and speed (also used to update the leader's marking

// Altitude
var altSpan = 0; //used to find the maximum absolute span between flight altitude
var maxAlt = 0; // Maximum altitude

var svgString = '<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200">' +
       '<foreignObject width="100%" height="100%">' +
       '<div xmlns="http://www.w3.org/1999/xhtml" style="font-size:40px; color: #FF0">' +
         '<em>I</em> like' + 
         '<span style="color:white; text-shadow:0 0 2px blue;">' +
         'Bird</span>' +
       '</div>' +
       '</foreignObject>' +
       '</svg>';

	  
// The string that is used for the content of the information frame (shown when an entity is selected)
var descriptionString = 'Bird'+' Information:'+
		'<div style="text-align:left; padding:5px">' +   '</div>'+
		'<div style="text-align:left; padding:5px">' +   '</div>';
		//'Name</div>';
		//+ '<div style="text-align:center; padding:15px"><button class="trace-button">' +
        //'Show/hide trace</button></div>';//+
		//'<div style="text-align:center; padding:15px"><button class="birdminus-button">' +
        //'Previous bird</button><button class="birdplus-button">' +
        //'Next bird</button></div>';
		//+'<select name="Birds" class="birdlist">';
	   
// Version for the controlPanel
var cpDescriptionString = //'<p> Some text</p>'+
		'<div style="text-align:center; padding:15px"><button class="trace-button"> Show/hide trace</button>'+'<button class="traceall-button" id="traceall">' + 'Show/hide all traces</button></div>' +
		'<div style="text-align:left;padding:15px"><div style="text-align:left;float:left; padding:15px"><button class="zoom-button"> Zoom to all</button></div>' +
		'<div style="text-align:left;padding:15px">Or select from bird list below: </div>'+
		//'<select name="InterPol" class="interpolations"><option value='+iplin+'>'+'Linear'+'</option><option value='+iplag+'>'+'Lagrange'+'</option><option value='+ipher+'>'+'Hermite'+'</option></select>' +
		'<select name="Birds" style="text-align:left;float:right" class="birdlist">';
		//'<div style="text-align:center; padding:15px"><button class="birdminus-button">' +
        //'Previous bird</button><button class="birdplus-button">' + 'Next bird</button></div>'+
		
// Altitude visualization
var altDescriptionString = '<div id ="altSpan"></div><div id="altAnimation"></div>';

//'<img id ="altLine" src="Altbar.png" vspace ="1"  alt="Grafik">';
	   // For the span of altitudes
			// Adapt his to screen size/resolution
function addBars(descString, minA) {
		descString += '<div class="chart" style="width:5%"><div class="chart" id="altBar" style="text-align:center; float:right; height: 100px; width:100%;">' +Math.trunc(minA)+'<div class="chartline"  id="altline" style="color:red; text-align:center;  width:5%; height: 5px;position:absolute"></div>';
		//<div class="chartline"  id="altline" style="text-align:center; right:0px; height: 10px; width:5%;position:absolute"></div>';
		
			// position:fixed;
			//cpDescriptionString +=  ' <script>' + 'myBarchart.draw();'+'<\/script>';
			return descString;
}
        
	var image = new Image();
	image.src = 'data:image/svg+xml;base64,' + window.btoa(svgString);


function addMultipleBillboards(scene) {

        Sandcastle.declare(addMultipleBillboards); // For highlighting in Sandcastle.

        Cesium.when.all([

                         Cesium.loadImage('../images/Cesium_Logo_overlay.png'),

                         Cesium.loadImage('../images/facility.gif')

                        ],

                        function(images) {

            // Once both images are downloaded, they are combined into one image,

            // called a texture atlas, which is assigned to a billboard-collection.

            // Several billboards can be added to the same collection; each billboard

            // references an image in the texture atlas.



            var billboards = new Cesium.BillboardCollection();

            var textureAtlas = scene.createTextureAtlas({

                images : images

            });

            billboards.textureAtlas = textureAtlas;

            // Logo

            billboards.add({

                position : ellipsoid.cartographicToCartesian(Cesium.Cartographic.fromDegrees(-75.59777, 40.03883)),

                imageIndex : 0

            });

            // Facility

            billboards.add({

                position : ellipsoid.cartographicToCartesian(Cesium.Cartographic.fromDegrees(-80.50, 35.14)),

                imageIndex : 1

            });



            // Facility

            billboards.add({

                position : ellipsoid.cartographicToCartesian(Cesium.Cartographic.fromDegrees(-80.12, 25.46)),

                imageIndex : 1

            });

            scene.primitives.add(billboards);

        });

    }


// #######################################


function startup(Cesium) {
    'use strict';
//Sandcastle_Begin

    var modus;

    var url_string = window.location.href;
    var url = new URL(url_string);
    console.log(url);
    modus = url.searchParams.get("mode");
    console.log(modus);


    if (modus == 'master' || modus == 'm') {
        modus = 'master'
    } else if (modus == 'slave' || modus == 's'){
        modus = 'slave'
    } else {
        modus = 'basic'
    }

    $.getScript('/../../../Sync/' + modus +'.js', function() {



/*
var viewer = new Cesium.Viewer('cesiumContainer', {
    imageryProvider : bing,
    baseLayerPicker : false,
    vrButton : true
});
*/

var options = {
    camera : viewer.scene.camera,
    canvas : viewer.scene.canvas
};

var birds = [];//new Array();
var dstrings = [];//new Array();
var timeLines = []; // for line chart, data and altitude


// Helper to draw lines
function drawLine(ctx, startX, startY, endX, endY,color){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.moveTo(startX,startY);
    ctx.lineTo(endX,endY);
    ctx.stroke();
    ctx.restore();
}

//Helper to draw bars
function drawBar(ctx, upperLeftCornerX, upperLeftCornerY, width, height,color){
    ctx.save();
    ctx.fillStyle=color;
    ctx.fillRect(upperLeftCornerX,upperLeftCornerY,width,height);
    ctx.restore();
}

var chartRect = function ()
{
    var canvas  = viewer.scene.canvas;
    var context = canvas.getContext('2d');

    var x       = 50;
    var y       = 50;
    var width   = 100;
    var height  = 100;
    
    context.strokeStyle = 'red';
    context.strokeRect(x, y, width, height);
}

var Barchart = function(options){
    this.options = options;
    this.canvas = options.canvas;
    this.ctx = this.canvas.getContext("2d");
    this.colors = options.colors;
  
    this.draw = function(){
        var maxValue = 0;
        for (var categ in this.options.data){
            maxValue = Math.max(maxValue,this.options.data[categ]);
        }
        var canvasActualHeight = this.canvas.height - this.options.padding * 2;
        var canvasActualWidth = this.canvas.width - this.options.padding * 2;
 
        //drawing the grid lines
        var gridValue = 0;
        while (gridValue <= maxValue){
            var gridY = canvasActualHeight * (1 - gridValue/maxValue) + this.options.padding;
            drawLine(
                this.ctx,
                0,
                gridY,
                this.canvas.width,
                gridY,
                this.options.gridColor
            );
             
            //writing grid markers
            this.ctx.save();
            this.ctx.fillStyle = this.options.gridColor;
            this.ctx.font = "bold 10px Arial";
            this.ctx.fillText(gridValue, 10,gridY - 2);
            this.ctx.restore();
 
            gridValue+=this.options.gridScale;
        }
  
        //drawing the bars
        var barIndex = 0;
        var numberOfBars = Object.keys(this.options.data).length;
        var barSize = (canvasActualWidth)/numberOfBars;
 
        for (categ in this.options.data){
            var val = this.options.data[categ];
            var barHeight = Math.round( canvasActualHeight * val/maxValue) ;
            drawBar(
                this.ctx,
                this.options.padding + barIndex * barSize,
                this.canvas.height - barHeight - this.options.padding,
                barSize,
                barHeight,
                this.colors[barIndex%this.colors.length]
            );
 
            barIndex++;
        }
  
    }
}

function progressTo(bird) {
 viewer.flyTo(bird).then(function(){
			viewer.clock.shouldAnimate = false;
                viewer.trackedEntity = bird;
                viewer.selectedEntity = viewer.trackedEntity;
                viewer.clock.multiplier = 1;
                viewer.clock.shouldAnimate = true;
})
}


Sandcastle.addDefaultToolbarMenu([
    {
        text: 'Select mode',
       
        onselect: function () { }
    },

{
    text : 'Bird flight',
   // onselect : function() {
   //     viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/kml/birds.kml', options)).then(function(dataSource){
   //         viewer.clock.shouldAnimate = false;
   //         var rider = dataSource.entities.getById('tour');
   //         viewer.flyTo(rider).then(function(){
   //             viewer.trackedEntity = rider;
   //             viewer.selectedEntity = viewer.trackedEntity;
   //             viewer.clock.multiplier = 2;
   //             viewer.clock.shouldAnimate = true;
  onselect : function() {
		//C:\Kaos\Data\Collective\Mate
		//viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/kml/2014-08-07-70.kml', options)).then(function(dataSource){//birds2 bird70 2014-08-07-70.kml
		//mate.kmz
        //viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/kml/b10.kml', options)).then(function(dataSource){//birds2 bird70 2014-08-07-70.kml
        
        viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/kml/2014-08-07-70.kml', options)).then(function(dataSource){//birds2 bird70 2014-08-07-70.kml
        
        	// will be filled by initialize
        	property = new Cesium.SampledPositionProperty();
        
			//initialize(Cesium, viewer, birds, property);
			
			 //for (i = 0; i < newData.length; i++) {
			//		console.log("Nehew subject ");
			 //}
			viewer.clock.shouldAnimate = false;
            var model = dataSource.entities.getById('bird1');
			var model2 = dataSource.entities.getById('bird2');

            //Create the entities after KML loaded
			var positions = new Array();
			//var birds = new Array();
			
            var position = model.position;
			var position2 = model2.position;
			
            //positions.add(position);
            var mydata = dataSource.entities.values;
			
			var loopSize = mydata.length;
			//console.log (loopSize);
			
			var HPR = new Cesium.HeadingPitchRoll((Cesium.Math.toRadians(270)), 0, 0);

			// Initialize the list of bird names for the select in the control panel
			for (var k = 0; k < loopSize; k++) {
				//descriptionString += '<option value='+k+'>'+mydata[k].id+'</option>';
				cpDescriptionString += '<option value='+k+'>'+mydata[k].name+'</option>'; //.id
				
			}
			
			
			
			cpDescriptionString += '</select></div>';
			var minAlt = 10000; //magic 
			//console.log(dataSource.entities); //dataSource.entities._entities.length
			// Only during start we want to store climbing speed per time point to compare between birds and find the fastest
			var climbingSpeed = []; // Holds the max climbing speed for each time point
			for (var i = 0; i < loopSize; i++) {
	
				var mymodel = mydata[i];
				
				// local reference frame for rotation, not positioning
				var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(
					Cesium.Cartesian3.fromDegrees(0, 0, 0.0));	
					// Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
				var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
				var heading = -Cesium.Math.PI_OVER_FOUR;//TWO;
				var pitch = 0;//Cesium.Math.PI_OVER_FOUR;
				var roll = 0.0;
				//var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
				var transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, HPR);
	//console.log(mymodel.name);
				dstrings.push(descriptionString);
				dstrings[dstrings.length-1] += 'Bird ID: '+mymodel.name +'<br/>';//'<div style="text-align:center; padding:15px">Zoom to all</div>';
				dstrings[dstrings.length-1] += '  Bird Name: '+ mymodel.id+'<br/>';
				//dstrings[dstrings.length-1] += '<div class="chart"><div style="width: 40px;">42</div></div>';
			
				// Altitude representation
				var ids = ' <div id="alter'+i+'" class="altErnative"></div>';
				//var idst = ' <div id="alter1" class="altErnative"></div>';
				//console.log(ids);
				altDescriptionString += ids;//'<div id=class="altErnative"></div>';

				// Testing if positions could be read
				//console.log(mydata[i].path);
				var resStart = mymodel.position.getValue(viewer.clock.startTime, new Cesium.Cartesian3());
				var resStop = mymodel.position.getValue(viewer.clock.stopTime, new Cesium.Cartesian3());
				var curTime = new Cesium.JulianDate; 

				Cesium.JulianDate.clone(viewer.clock.startTime,curTime);
				//Object.assign(curTime, viewer.clock.startTime);
				//var curTime = viewer.clock.startTime;
				var endTime = viewer.clock.stopTime;
				
				// Get start and end altitude
				var startAlt = Cesium.Cartographic.fromCartesian(resStart).height;
				var stopAlt = Cesium.Cartographic.fromCartesian(resStop).height;
				var altGain = stopAlt - startAlt;
				var lastAlt = startAlt;
				var altChanges = "Altitude changes ";
				// This is not yet including the intermediate altitude
				if (startAlt < minAlt) minAlt = startAlt;
				if (stopAlt < minAlt) minAlt = stopAlt;
				
				
				var m = 1;
                var tmpPosition = new Cesium.SampledPositionProperty();
                //console.log(typeof mymodel.position);
                Object.assign(tmpPosition, mymodel.position);
                
                // How to get current altitude
				
				var timeLine = [];
				var timePointIndex = 0; // at which timepoint are we right now
                while (Cesium.JulianDate.compare(curTime, endTime) < 0) {
					var currentAlt = mymodel.position.getValue(curTime, new Cesium.Cartesian3());
					var height = Cesium.Cartographic.fromCartesian(currentAlt).height;
					if (height > maxAlt) maxAlt = height;
                    ////
					///
						var parseDate = d3.timeParse("%0d-%0m-%Y-%H-%M-%S");
						
						///
					var tmpDate = Cesium.JulianDate.toDate(curTime);
					var dateString = tmpDate.getDate()+"-"+tmpDate.getMonth()+"-"+tmpDate.getFullYear()+"-"+tmpDate.getHours()+"-"+tmpDate.getMinutes()+"-"+tmpDate.getSeconds();
					
					timeLine.push(
					{
						date: parseDate(dateString),
						//date: Cesium.JulianDate.toIso8601(curTime).split("T")[0],
						alt: height
					}
					);
					//console.log(timeLine[timeLine.length-1]);
					
					////
					var nextTime = new Cesium.JulianDate;
					Cesium.JulianDate.clone(curTime, nextTime);
					//result next or cur?
                    nextTime = Cesium.JulianDate.addSeconds(curTime, timeGranularity, nextTime);
					// Now take care that the height is not undefined
					if (Cesium.JulianDate.compare(nextTime, endTime) <= 0) {
						//var currentAlt = mymodel.position.getValue(curTime, new Cesium.Cartesian3());
						var nextAlt = mymodel.position.getValue(nextTime, new Cesium.Cartesian3());
						//var height = Cesium.Cartographic.fromCartesian(currentAlt).height;
						//if (height > maxAlt) maxAlt = height;
						var climb = Cesium.Cartographic.fromCartesian(nextAlt).height - Cesium.Cartographic.fromCartesian(currentAlt).height;
						if (i == 0) {
							climbingSpeed[climbingSpeed.length] = climb;
							climbingBird[climbingBird.length] = 0;
							//console.log(timePointIndex+' '+i+' '+climb);
						}
						else {
							if (climb > climbingSpeed[timePointIndex]) {
								climbingSpeed[timePointIndex] = climb;
								climbingBird[timePointIndex] = i;
								//console.log(timePointIndex+' '+i);
							}
							//else {
							//	console.log(climb);
							//}
						}
						timePointIndex++;
					}
					Cesium.JulianDate.addSeconds(curTime, timeGranularity, curTime);
					
				}
				timeLines.push(timeLine);
				console.log(altChanges);
				fastestClimbingBird = climbingBird[0];
				
				dstrings[dstrings.length-1] += '  Altitude gain '+ altGain;
				
				
				console.log(startAlt+" "+stopAlt);
				
				// Position in radians and altitude in meters
				console.log(Cesium.Cartographic.fromCartesian(mymodel.position.getValue(viewer.clock.startTime)));
			
                var theSphere = viewer.entities.add({
                    position: mymodel.position, //Cesium.Cartesian3.fromDegrees(-98.0, 45.0, height),
                    ellipsoid: {
                        radii: new Cesium.Cartesian3(10.0, 10.0, 10.0),
                        outline: true,
                        outlineColor: Cesium.Color.WHITE,
                        outlineWidth: 2,
                        material: Cesium.Color.fromAlpha(Cesium.Color.WHITE,0.35)//Cesium.Color.fromRandom({ alpha: 0.5 })						
						//granularity: Cesium.Math.RADIANS_PER_DEGREE*2
                    },
					show: false,
                    description: 'Bird ID'+mymodel.id,
                    birdId: i,
                    bid: i,
                    //id: mymodel.id,
                    name: "Sphere"//,
                    //parent: theBird
                });
				
				var degreeArray = [];
			for (var li = 0; li < mymodel.position.length; li++) {
				degreeArray.push(mymodel.position[i].longitude);
				degreeArray.push(mymodel.position[i].latitude);
				degreeArray.push(mymodel.position[i].height);
			}
				mymodel.position
			// Add entities
			// This is just the index!
			
			var theBird = birds.push(
				viewer.entities.add({
					position: mymodel.position,
					orientation: new Cesium.VelocityOrientationProperty(mymodel.position),
					model: {
						uri: '../../SampleData/models/FlyingBird/storch_model_2017__1_7lq90.glb',//FalconRotate.gltf', //FalconColor.glb', //Duck.gltf',//bird.gltf /b789.glb
						minimumPixelSize: 32,
						color: Cesium.Color.LIGHTGREY//YELLOW
                    },
                    sphere : theSphere,
					name: mymodel.name,  //.id
					modelMatrix: transform,
					description : dstrings[dstrings.length-1], //descriptionString,
					path: {
						resolution: 1,
						leadTime: 1,
						trailTime: 20,
						material:
						new Cesium.PolylineGlowMaterialProperty({
							glowPower: 1.0,
							color: Cesium.Color.WHITE
						}),
					width: 2
					},
					color: Cesium.Color.WHITE, //Test, remove
					//_color: Cesium.Color.WHITE, //Test, remove
					polyline: {
						//depthFailMaterial: Cesium.Color.WHITE,
						//color: Cesium.Color.WHITE,
						material: Cesium.Color.WHITE//new Cesium.PolylineOutlineMaterialProperty({//PolylineGlowMaterialProperty({
							////glowPower : 1,
							//outlineColor: Cesium.Color.BLUE,
							//color : Cesium.Color.BLUE
							//})
					},
					//wall: {
					//	material : Cesium.Color.BLUE.withAlpha(0.5),
					//	positions: Cesium.Cartesian3.fromDegreesArrayHeights(degreeArray)
					//},
					myIndex : i,
					altGain : altGain,
					tracker: "bird"
		//,orientation : orientation1

                }));
            theSphere.addProperty("pid");
			

    //);



    //console.log('Another bird');
	if (i >= 0) {
	//console.log(birds[0]);
		mymodel.show = false;
		//birds[i].polyline.material = Cesium.Color.clone(Cesium.Color.GREEN);
		//console.log(" Bird: "+bviewer,entities[0]);//.polyline.material = Cesium.Color.GREEN;
	}
	
	}
	lineChart(timeLines[0]);
	birds[fastestClimbingBird].sphere.show = true;
	console.log("Vögel: "+birds.length);
	
	//console.log("Avail "+birds[0].isAvailable(viewer.clock.startTime)); //viewer.entities.computeAvailability());
	//viewer.entities.computeAvailability();
	//console.log("Avail "+birds[0].position.getValue()); //viewer.entities.computeAvailability());
	// Initialize
	var debug = 1;
	viewer.clock.onTick.addEventListener(function(clock)
	{
		if (viewer.vrButton.isVRMode) {
			console.log("Is on");
			viewer.scene.useWebVR = true;
		}
		var theTime = Math.trunc(clock.currentTime.secondsOfDay % tickTime); // actually larger values than 60 are possible for now
	
		var time = new Date().getTime();
		//console.log(theTime);
		// Every few seconds
		if (theTime == 0) {
			// do something
			//console.log(birds[0].position[0]);//.getCurrentPosition().latitude
		}
		// Now we calculate the index of the current time in the best lists
		var stTime = new Cesium.JulianDate; 

		Cesium.JulianDate.clone(viewer.clock.startTime,stTime);
		var timeDiff = Math.floor(Cesium.JulianDate.secondsDifference(clock.currentTime, stTime)/ timeGranularity);
		
		//console.log(fastestClimbingBird);
		//console.log(climbingBird[timeDiff]);
		if (climbingBird[timeDiff] != fastestClimbingBird) {
			birds[fastestClimbingBird].sphere.material = Cesium.Color.CORNSILK;
			birds[fastestClimbingBird].sphere.show = false;
			birds[climbingBird[timeDiff]].sphere.material = Cesium.Color.CORAL;
			fastestClimbingBird = climbingBird[timeDiff];
			birds[fastestClimbingBird].sphere.show = true;
		}
		
		// Move altitude bar
		// Make that bullet proof without magic numbers asap
		if (viewer.selectedEntity != null && viewer.selectedEntity != undefined)
		{
			var thePos = viewer.selectedEntity._position.getValue(viewer.clock.currentTime, new Cesium.Cartesian3());
			var altitude =  Cesium.Cartographic.fromCartesian(thePos).height;
		
			var elem = document.getElementById("altAnimation"); 
			//var curPos = elem.style.top.substring(0,elem.style.top.length-2);
			//var poschange = parseInt(curPos)+5;
			//console.log(poschange);
			elem.style.top = 10+(maxAlt-altitude)/maxAlt*180 +  'px';
		}
		//"alter'+i+'"
		for (k = 0; k < birds.length; k++) {
			var thePosi = birds[k]._position.getValue(viewer.clock.currentTime, new Cesium.Cartesian3());
			var alti =  Cesium.Cartographic.fromCartesian(thePosi).height;
			var altids = 'alter'+k;
			
			var elem = document.getElementById(altids);
			if (elem != undefined) {
				elem.style.top = 10+(maxAlt-alti)/maxAlt*180 +  'px';
			}
			//console.log(thePosi);
		}
		//time = Math.floor(time/100);//100ms
		//var percent = time % 100;
		//if(percent<10){percent=100;}
		//viewer.infoBox._element.style.width=percent.toString()+"%";
	});

	//#################################
	// Try to play the animation
	Cesium.when(birds[1].readyPromise).then(function(bird1) {
		bird1.activeAnimations.addAll({
			loop : Cesium.ModelAnimationLoop.REPEAT
		});
	});
	//console.log (viewer.entities.values.length);

var scene = viewer.scene;
console.log(viewer.clock.startTime);
console.log(viewer.clock.clockStep);
console.log(viewer.clock.clockRange);


// Model pick handler for testing

var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);

var entity = viewer.entities.add({
        label : {
            show : false,
            showBackground : true,
            font : '48px monospace',
            horizontalOrigin : Cesium.HorizontalOrigin.LEFT,
            verticalOrigin : Cesium.VerticalOrigin.TOP,
            pixelOffset : new Cesium.Cartesian2(15, 0)
        }
    });

handler.setInputAction(function (movement) {
        var pick = scene.pick(movement.endPosition);
        if (Cesium.defined(pick) && Cesium.defined(pick.node) && Cesium.defined(pick.mesh)) {
            //console.log('node: ' + pick.node.name + '. mesh: ' + pick.mesh.name);	
			
			var longitudeString = Cesium.Math.toDegrees(cartographic.longitude).toFixed(2);
            var latitudeString = Cesium.Math.toDegrees(cartographic.latitude).toFixed(2);
			entity.position = pick;
            entity.label.show = true;
            entity.label.text =
                'Lon: ' + ('   ' + longitudeString).slice(-7) + '\u00B0' +
                '\nLat: ' + ('   ' + latitudeString).slice(-7) + '\u00B0';
        }
    },
    Cesium.ScreenSpaceEventType.MOUSE_MOVE
);

// Handle all stuff when bird selection is changed
function updateViews(birdie) {
	lineChart(timeLines[birdie.myIndex]);
}
function selectBird(birdie) {
	viewer.trackedEntity = birdie;
    viewer.selectedEntity = birdie;
	updateViews(birdie);
}

// Camera zoom
var cartographic = new Cesium.Cartographic();
var ellipsoid = viewer.scene.mapProjection.ellipsoid;
var cartesian = new Cesium.Cartesian3();

function setHeight(height) {
    ellipsoid.cartesianToCartographic(viewer.scene.camera.position, cartographic);
    cartographic.height = height;  // convert to meters
	//console.log(cartographic.height);
	//console.log(viewer.scene.camera.getMagnitude());
    ellipsoid.cartographicToCartesian(cartographic, cartesian);
    viewer.scene.camera.position = cartesian;
}


            //
    handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    handler.setInputAction(function (click) {
        var pickedObject = viewer.scene.pick(click.position);

        /* if (pickedObject instanceof Cesium.Cesium3DTileFeature) 
        {
            var propertyNames = pickedObject.getPropertyNames();
            var length = propertyNames.length;
            for (var i = 0; i < length; ++i) {
                var propertyName = propertyNames[i];
                console.log(propertyName + ': ' + pickedObject.getProperty(propertyName));
            }
        }*/
//console.log(click);
        if (Cesium.defined(pickedObject)) {
            var entityId = pickedObject.id._id;
            var obj = viewer.entities.getById(entityId);
            if (obj._name == 'Sphere'){
            	viewer.selectedEntity = birds[obj._birdId];
				
            	 var thePos = birds[obj._birdId]._position.getValue(viewer.clock.currentTime, new Cesium.Cartesian3());
                 var altitude =  Cesium.Cartographic.fromCartesian(thePos).height;
            } else
			// Check if we hit a bird
			if (Cesium.defined(obj.tracker)) {
				//viewer.selectedEntity.model.color = Cesium.Color.CORAL;
				viewer.selectedEntity = obj;
			}
			updateViews(viewer.selectedEntity);
			
            //console.log(entityId + pickedObject.position);
            //console.log(viewer.entities.getById(entityId));
            //viewer.selectedEntity = viewer.getById(birds[pickedObject.bid].id);
            //console.log(pickedObject.birdId);
                //pickedObject.properties.hasProperty("pid"));
            //if (Cesium.defined(pickedObject.pid)) {
              //  console.log(pickedObject.pid);
                //viewer.selectedEntity = pickedObject.parent;
            //}
        } else {
			lineChart(undefined);
		}
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
            //

document.getElementById('radioSphere').addEventListener('click', function (e) {
    // Either on bird or all
    /*
    if (e.target && e.target.id === 'bird') {
        //console.log('clicked')
        viewer.trackedEntity.sphere.show = false;
    } else { viewer.trackedEntity.sphere.show = true;}
    */
	
    if (e.target && e.target.id == "sphere"){
        for ( i = 0; i < birds.length; i++ ) {
                birds[i].sphere.show = true; //!birds[i].sphere.show;
    	}
    }
    else { 
		if (e.target && e.target.id == "bird"){
			for ( i = 0; i < birds.length; i++ ) {
				birds[i].sphere.show = false; //!birds[i].sphere.show;
			} 
		}
	}
            }, false);
	
	
document.getElementById('radioPanel').addEventListener('click', function (e) {
	if (e.target && e.target.id == "altpanel"){
		if ($('#controlPanelAlt').css("visibility") == 'hidden') {
				$('#controlPanelAlt').css('visibility', 'visible');
			}
			else {
				$('#controlPanelAlt').css('visibility', 'hidden');
		}
		if ($('#d3panel').css("visibility") == 'hidden') {
				$('#d3panel').css('visibility', 'visible');
			}
			else {
				$('#d3panel').css('visibility', 'hidden');
		}
	}
}, false);
	
document.getElementById('radioCPanel').addEventListener('click', function (e) {
	if (e.target && e.target.id == "conpanel"){
		if ($('#controlPanel').css("visibility") == 'hidden') {
				$('#controlPanel').css('visibility', 'visible');
			}
			else {
				$('#controlPanel').css('visibility', 'hidden');
		}
	}
}, false);

	
viewer.infoBox.frame.contentDocument.body.addEventListener('click', function(e) {
        //
        // The document body will be rewritten when the selectedEntity changes,
        // but this body listener will survive.  Now it must determine if it was
        // one of the clickable buttons.
        //
        if (e.target && e.target.className === 'trace-button') {
           //console.log(viewer.selectedEntity.myIndex);
		   mydata[viewer.selectedEntity.myIndex].show = !mydata[viewer.selectedEntity.myIndex].show;
            //updateDisplay();
        } else
		if (e.target && e.target.className === 'birdplus-button') {
           //console.log(viewer.selectedEntity.myIndex);
		   var nextEntity = birds[(viewer.selectedEntity.myIndex-1) % birds.length];
		   
		   selectBird(nextEntity);
		   //viewer.trackedEntity = nextEntity;
           //viewer.selectedEntity = viewer.trackedEntity;
		   
		   //mydata[viewer.selectedEntity.myIndex].show = !mydata[viewer.selectedEntity.myIndex].show;
            //updateDisplay();
        } else
		if (e.target && e.target.className === 'birdminus-button') {
           //console.log(viewer.selectedEntity.myIndex);
		   var nextEntityMinus = birds[(viewer.selectedEntity.myIndex-1) % birds.length];
		   
		   selectBird(nextEntityMinus);
		   //viewer.trackedEntity = nextEntityMinus;
           //viewer.selectedEntity = viewer.trackedEntity;
        } 
    }, false);
	
viewer.infoBox.frame.contentDocument.body.addEventListener('change', function(e) {
		if (e.target && e.target.className === 'birdlist') {
           //console.log("Select");
		   //console.log(e.target.value);
		   viewer.trackedEntity = birds[e.target.value];
		   viewer.selectedEntity = birds[e.target.value];
        }
}, false);	

document.getElementById('birdMinus').addEventListener('click', function() {
	
	var newIndex = ((((viewer.selectedEntity.myIndex-1) % birds.length) + birds.length) % birds.length);
	//console.log(newIndex);
	var nextEntityMinus = birds[newIndex];
		   //console.log(viewer.selectedEntity);
		   selectBird(nextEntityMinus);
		   //viewer.trackedEntity = nextEntityMinus;
           //viewer.selectedEntity = viewer.trackedEntity;
		   lineChart(timeLines[newIndex]);
}, false);

document.getElementById('birdPlus').addEventListener('click', function() {
	
	ellipsoid.cartesianToCartographic(viewer.scene.camera.position, cartographic);
	var camerah = cartographic.height;
	var cameramag = viewer.scene.camera.getMagnitude();
	var nextEntityPlus = birds[(viewer.selectedEntity.myIndex+1) % birds.length];
		   
	viewer.flyTo(nextEntityPlus).then(function(){
				viewer.clock.shouldAnimate = false;
                viewer.trackedEntity = nextEntityPlus;
                viewer.selectedEntity = viewer.trackedEntity;
                viewer.clock.multiplier = 1;
				setHeight(camerah);
                viewer.clock.shouldAnimate = true;
    });
	selectBird(nextEntityPlus);
		   //viewer.trackedEntity = nextEntityPlus;
           //viewer.selectedEntity = viewer.trackedEntity;
		   //console.log(camerah);
	setHeight(camerah);
	viewer.scene.camera.moveUp(100);
	
	//lineChart(timeLines[(viewer.selectedEntity.myIndex+1) % birds.length]);
	//cameramag-viewer.scene.camera.getMagnitude());
}, false);


document.getElementById('textspace').innerHTML = cpDescriptionString;
document.getElementById('controlPanelAlt').innerHTML = altDescriptionString;
//document.getElementById('altSpace').innerHTML = altDescriptionString;
	
	
document.getElementById('controlPanel').addEventListener('click', function(e) {
	if (e.target && e.target.className === 'trace-button') {
	
		mydata[viewer.selectedEntity.myIndex].show = !mydata[viewer.selectedEntity.myIndex].show;
		//console.log(mydata[viewer.selectedEntity.myIndex].kml.author);
	} else
	if (e.target && e.target.className === 'traceall-button') {
		var traces = false;
	// Assumes that we have a representation for each data model
	
	for (var i = 0; i < loopSize; i++) { 
		traces = traces || mydata[i].show;
	}
	traces = !traces;
	for (var i = 0; i < loopSize; i++) { 
		mydata[i].show = traces; //!mydata[i].show;
	}
	}
	else if (e.target && e.target.className === 'zoom-button') {
		viewer.flyTo(viewer.entities);
	}
});



//VRTheWorldTerrainProvider
//Cesium.ArcGisImageServerTerrainProvider
var terrainProvider = new Cesium.CesiumTerrainProvider({
    url : 'https://assets.agi.com/stk-terrain/v1/tilesets/world/tiles',
	requestVertexNormals: true
	//,requestWaterMask: true
});

//HighQ
var terrainProviderMeshes = new Cesium.CesiumTerrainProvider({
    url : 'https://assets.agi.com/stk-terrain/v1/tilesets/PAMAP/tiles',
    requestWaterMask : true,
    requestVertexNormals : true
});

//var terrainProviderVR = new Cesium.VRTheWorldTerrainProvider({
//  url : 'https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/'
//});
viewer.terrainProvider = terrainProvider;

viewer.terrainProvider = terrainProviderMeshes;
//viewer.terrainProvider = terrainProvider;

viewer.terrainProvider = terrainProvider;
viewer.scene.globe.enableLighting = true;

    

// Interface
// Toolbar --------------------------

//----------------------------------



	
//-----
//Add button to view the path from the top down, not working as it moves the time outside the KML range
/*
Sandcastle.addDefaultToolbarButton('View Top Down', function() {
    viewer.trackedEntity = undefined;
    viewer.zoomTo(viewer.entities, new Cesium.HeadingPitchRange(0, Cesium.Math.toRadians(-90)));
});
  

//Add button to view the path from the side
Sandcastle.addToolbarButton('View Side', function() {
    viewer.trackedEntity = undefined;
    viewer.zoomTo(viewer.entities, new Cesium.HeadingPitchRange(Cesium.Math.toRadians(-90), Cesium.Math.toRadians(-15), 7500));
});

   //             viewer.clock.shouldAnimate = true;
            //Add button to track the entity as it moves
Sandcastle.addToolbarButton('View bird1', function() {
    //viewer.trackedEntity = bird[1];
	mydata[1].show = false;
})
*/

// Check why this doesn't work
//progressTo(bird1);

            viewer.flyTo(birds[0]).then(function(){ //bird1).then(function(){
			viewer.clock.shouldAnimate = false;
                viewer.trackedEntity = birds[0];
                viewer.selectedEntity = viewer.trackedEntity;
                viewer.clock.multiplier = 1;
                viewer.clock.shouldAnimate = true;
            });
			
        });
    } // bird adventure on select
    },
    {
        text: 'Simple Bird flight',
        onselect: function () {
            viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/kml/Aug0731.kml', options)).then(function (dataSource) {
                viewer.clock.shouldAnimate = false;
                var rider = dataSource.entities.getById('tour');

                rider.model =
                    {
                        uri: '../../SampleData/models/FlyingBird/storch_model_2017__1_7lq90.glb',//FalconRotate.gltf', //FalconColor.glb', //Duck.gltf',//bird.gltf /b789.glb
                        minimumPixelSize: 32,
                        color: Cesium.Color.ALICEBLUE//YELLOW
                    };
                rider.orientation = new Cesium.VelocityOrientationProperty(rider.position);



                viewer.flyTo(rider).then(function () {
                    /*
                        viewer.entities.add({
                            model: {
                                uri: '../../SampleData/models/FlyingBird/storch_model_2017__1_7lq90.glb',//FalconRotate.gltf', //FalconColor.glb', //Duck.gltf',//bird.gltf /b789.glb
                                minimumPixelSize: 32,
                                color: Cesium.Color.ALICEBLUE//YELLOW
                            },
                    }); 
                    */
                    viewer.trackedEntity = rider;
                    viewer.selectedEntity = viewer.trackedEntity;
                    viewer.clock.multiplier = 2;
                    viewer.clock.shouldAnimate = true;
                });
            });
        }
    },

], 
'toolbar'); //default toolbar

document.getElementById('controlPanel').addEventListener('change', function(e) {
		if (e.target && e.target.className === 'birdlist') {
           console.log("Select");
		   console.log(e.target.value);
		   viewer.trackedEntity = birds[e.target.value];
		   viewer.selectedEntity = birds[e.target.value];
        } else
		if (e.target && e.target.className === 'interpolations') {
			var theDegree = 1;
			var theApprox = Cesium.LinearApproximation;
			switch (e.target.value) {
			 case iplin: theDegree = 1; theApprox = Cesium.LinearApproximation; break;
			 case iplag: theDegree = 5; theApprox = Cesium.LagrangePolynomialApproximation; break;
			 case ipher: theDegree = 2; theApprox = Cesium.HermitePolynomialApproximation;break;
			 default: theDegree = 1; // linear
			}

			for (var l = 0; l < viewer.entities.length; l++) {
			birds[l].position.setInterpolationOptions({
				interpolationDegree : theDegree,
				interpolationAlgorithm : theApprox
			});
			}
		}
}, false);	



	Sandcastle.reset = function() {
		viewer.dataSources.removeAll();
		viewer.clock.clockRange = Cesium.ClockRange.UNBOUNDED;
		viewer.clock.clockStep = Cesium.ClockStep.SYSTEM_CLOCK;
	};
	
// Check why this is not working	
	/*
	//Add a combo box for selecting each interpolation mode.
	Sandcastle.addToolbarMenu([{
    text : 'Interpolation: Linear Approximation',
    onselect : function() {
        viewer.trackedEntity.position.setInterpolationOptions({
            interpolationDegree : 1,
            interpolationAlgorithm : Cesium.LinearApproximation
        });
    }
}, {
    text : 'Interpolation: Lagrange Polynomial Approximation',
    onselect : function() {
        viewer.trackedEntity.position.setInterpolationOptions({
            interpolationDegree : 5,
            interpolationAlgorithm : Cesium.LagrangePolynomialApproximation
        });
    }
}, {
    text : 'Interpolation: Hermite Polynomial Approximation',
    onselect : function() {
        viewer.trackedEntity.position.setInterpolationOptions({
            interpolationDegree : 2,
            interpolationAlgorithm : Cesium.HermitePolynomialApproximation
        });
    }
}], 'interpolationMenu');
*/




    }); // End of master for synchronization

//Sandcastle_End
    Sandcastle.finishedLoading();
} // startup cesium
if (typeof Cesium !== "undefined") {
    startup(Cesium);
} else if (typeof require === "function") {
    require(["Cesium"], startup);
}


</script>
</body>
</html>
